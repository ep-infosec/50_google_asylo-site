<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asylo: asylo Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/favicons/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asylo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">asylo Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceasylo_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasylo_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasylo_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasylo_1_1primitives"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo_1_1primitives.html">primitives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasylo_1_1sgx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo_1_1sgx.html">sgx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1AeadCryptor.html">AeadCryptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AEAD cryptor that provides <a class="el" href="classasylo_1_1AeadCryptor.html#a7198e92c0f96db5c4c8b49b7383bd95a" title="Implements the AEAD Seal operation. ">Seal()</a> and <a class="el" href="classasylo_1_1AeadCryptor.html#ad4a80effdadf95628736d3610a1d9e66" title="Implements the AEAD Open operation. ">Open()</a> functionality.  <a href="classasylo_1_1AeadCryptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1CheckOpMessageBuilder.html">CheckOpMessageBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for formatting "expr (V1 vs. V2)" in a CHECK_XX statement.  <a href="classasylo_1_1CheckOpMessageBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveAssertionAuthority.html">EnclaveAssertionAuthority</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classasylo_1_1EnclaveAssertionAuthority.html" title="An EnclaveAssertionAuthority is an authority for assertions of a particular identity type...">EnclaveAssertionAuthority</a> is an authority for assertions of a particular identity type.  <a href="classasylo_1_1EnclaveAssertionAuthority.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveAssertionGenerator.html">EnclaveAssertionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an interface for assertion authorities that create assertion offers and generate assertions.  <a href="classasylo_1_1EnclaveAssertionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveAssertionVerifier.html">EnclaveAssertionVerifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an interface for assertion authorities that generate assertion requests and verify assertions.  <a href="classasylo_1_1EnclaveAssertionVerifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveAuthContext.html">EnclaveAuthContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the authentication properties of an EKEP-based gRPC connection.  <a href="classasylo_1_1EnclaveAuthContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveClient.html">EnclaveClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract enclave client.  <a href="classasylo_1_1EnclaveClient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options used to configure a <code>::grpc::ChannelCredentials</code> object or a <code>::grpc::ServerCredentials</code> object for use in an enclave system.  <a href="structasylo_1_1EnclaveCredentialsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveLoader.html">EnclaveLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract enclave loader.  <a href="classasylo_1_1EnclaveLoader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveManager.html">EnclaveManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manager object responsible for creating and managing enclave instances.  <a href="classasylo_1_1EnclaveManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1EnclaveManagerOptions.html">EnclaveManagerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enclave Manager configuration.  <a href="classasylo_1_1EnclaveManagerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1IdentityExpectationMatcher.html">IdentityExpectationMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an abstract interface that describes how to match an <code>EnclaveIdentity</code> against an <code>EnclaveIdentityExpectation</code>.  <a href="classasylo_1_1IdentityExpectationMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1LogMessage.html">LogMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a log message created by a log macro.  <a href="classasylo_1_1LogMessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1LogMessageFatal.html">LogMessageFatal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A LogSeverity FATAL (or QFATAL) version of <a class="el" href="classasylo_1_1LogMessage.html" title="Class representing a log message created by a log macro. ">LogMessage</a> that the compiler can interpret as noreturn.  <a href="classasylo_1_1LogMessageFatal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1LogMessageVoidify.html">LogMessageVoidify</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used just to take an <code>ostream</code> type and make it a <code>void</code> type to satisify the ternary operator in <code>LOG_IF</code>.  <a href="classasylo_1_1LogMessageVoidify.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1NamedIdentityExpectationMatcher.html">NamedIdentityExpectationMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classasylo_1_1NamedIdentityExpectationMatcher.html" title="A NamedIdentityExpectationMatcher is capable of matching an identity to an expectation if the identit...">NamedIdentityExpectationMatcher</a></code> is capable of matching an identity to an expectation if the identity and the expectation's reference identity have the same identity descriptions, and they match the identity description returned by the <code><a class="el" href="classasylo_1_1NamedIdentityExpectationMatcher.html#a89dfc199a0d57143e60f6138caa22ea4" title="Returns the description of the enclave identities/enclave identity expectations this matcher is able ...">Description()</a></code> method of the matcher.  <a href="classasylo_1_1NamedIdentityExpectationMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasylo_1_1Namer_3_01NamedIdentityExpectationMatcher_01_4.html">Namer&lt; NamedIdentityExpectationMatcher &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1NonceGenerator.html">NonceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a nonce-generator interface.  <a href="classasylo_1_1NonceGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1NullAssertionGenerator.html">NullAssertionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the <a class="el" href="classasylo_1_1EnclaveAssertionGenerator.html" title="Defines an interface for assertion authorities that create assertion offers and generate assertions...">EnclaveAssertionGenerator</a> interface for null assertions.  <a href="classasylo_1_1NullAssertionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1NullAssertionVerifier.html">NullAssertionVerifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the <a class="el" href="classasylo_1_1EnclaveAssertionVerifier.html" title="Defines an interface for assertion authorities that generate assertion requests and verify assertions...">EnclaveAssertionVerifier</a> interface for null assertions.  <a href="classasylo_1_1NullAssertionVerifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html">SecretSealer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxAgeRemoteAssertionGenerator.html">SgxAgeRemoteAssertionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-safe implementation of the <a class="el" href="classasylo_1_1EnclaveAssertionGenerator.html" title="Defines an interface for assertion authorities that create assertion offers and generate assertions...">EnclaveAssertionGenerator</a> interface for SGX remote assertions generated by the Assertion Generator Enclave (AGE).  <a href="classasylo_1_1SgxAgeRemoteAssertionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxAgeRemoteAssertionVerifier.html">SgxAgeRemoteAssertionVerifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implemention of the <a class="el" href="classasylo_1_1EnclaveAssertionVerifier.html" title="Defines an interface for assertion authorities that generate assertion requests and verify assertions...">EnclaveAssertionVerifier</a> interface for SGX remote assertions generated by the Assertion Generator Enclave.  <a href="classasylo_1_1SgxAgeRemoteAssertionVerifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxIdentityExpectationMatcher.html">SgxIdentityExpectationMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classasylo_1_1SgxIdentityExpectationMatcher.html" title="SgxIdentityExpectationMatcher is capable of matching SGX identities with SGX identity expectations...">SgxIdentityExpectationMatcher</a></code> is capable of matching SGX identities with SGX identity expectations.  <a href="classasylo_1_1SgxIdentityExpectationMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxIntelEcdsaQeRemoteAssertionGenerator.html">SgxIntelEcdsaQeRemoteAssertionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code><a class="el" href="classasylo_1_1EnclaveAssertionGenerator.html" title="Defines an interface for assertion authorities that create assertion offers and generate assertions...">EnclaveAssertionGenerator</a></code> that generates assertions using the Intel ECDSA quoting enclave.  <a href="classasylo_1_1SgxIntelEcdsaQeRemoteAssertionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxIntelEcdsaQeRemoteAssertionVerifier.html">SgxIntelEcdsaQeRemoteAssertionVerifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code><a class="el" href="classasylo_1_1EnclaveAssertionVerifier.html" title="Defines an interface for assertion authorities that generate assertion requests and verify assertions...">EnclaveAssertionVerifier</a></code> that verifiers assertions generated by the Intel ECDSA quoting enclave.  <a href="classasylo_1_1SgxIntelEcdsaQeRemoteAssertionVerifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxLocalAssertionGenerator.html">SgxLocalAssertionGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the <a class="el" href="classasylo_1_1EnclaveAssertionGenerator.html" title="Defines an interface for assertion authorities that create assertion offers and generate assertions...">EnclaveAssertionGenerator</a> interface for SGX local assertions.  <a href="classasylo_1_1SgxLocalAssertionGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxLocalAssertionVerifier.html">SgxLocalAssertionVerifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implemention of the <a class="el" href="classasylo_1_1EnclaveAssertionVerifier.html" title="Defines an interface for assertion authorities that generate assertion requests and verify assertions...">EnclaveAssertionVerifier</a> interface for SGX local assertions.  <a href="classasylo_1_1SgxLocalAssertionVerifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SgxLocalSecretSealer.html">SgxLocalSecretSealer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the <a class="el" href="classasylo_1_1SecretSealer.html">SecretSealer</a> abstract interface that binds the secrets to the enclave identity on a local machine.  <a href="classasylo_1_1SgxLocalSecretSealer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SharedName.html">SharedName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A name shared between trusted and untrusted code.  <a href="classasylo_1_1SharedName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SharedResourceManager.html">SharedResourceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manager object for shared resources.  <a href="classasylo_1_1SharedResourceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1Status.html">Status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> contains information about an error.  <a href="classasylo_1_1Status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for representing either a usable value, or an error.  <a href="classasylo_1_1StatusOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1TrustedApplication.html">TrustedApplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for trusted applications.  <a href="classasylo_1_1TrustedApplication.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a135dc48e2850e970403849e585300222"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a135dc48e2850e970403849e585300222">CleansingString</a> = std::basic_string&lt; char, std::char_traits&lt; char &gt;, CleansingAllocator&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a135dc48e2850e970403849e585300222"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that zeros its memory on free.  <a href="#a135dc48e2850e970403849e585300222">More...</a><br /></td></tr>
<tr class="separator:a135dc48e2850e970403849e585300222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aec28a454f8e329b3cd81ef525ea753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9aec28a454f8e329b3cd81ef525ea753"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a9aec28a454f8e329b3cd81ef525ea753">CleansingVector</a> = std::vector&lt; T, CleansingAllocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a9aec28a454f8e329b3cd81ef525ea753"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector container that zeros its memory on free.  <a href="#a9aec28a454f8e329b3cd81ef525ea753">More...</a><br /></td></tr>
<tr class="separator:a9aec28a454f8e329b3cd81ef525ea753"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad9ce7785495cca99df26647b7762dcbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">SgxIdentityMatchSpecOptions</a> { <a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbda5b39c8b553c821e7cddc6da64b5bd2ee">SgxIdentityMatchSpecOptions::DEFAULT</a>, 
<a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbdac2d5dca3ad8552b2447b19b538b93584">SgxIdentityMatchSpecOptions::STRICT_LOCAL</a>, 
<a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbda6f0a9f12a74dedb34630ba69fc4d67e7">SgxIdentityMatchSpecOptions::STRICT_REMOTE</a>
 }<tr class="memdesc:ad9ce7785495cca99df26647b7762dcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum defines a set of recommended match specs.  <a href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad9ce7785495cca99df26647b7762dcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aebb535adde7099f90ae8da5b9670d3ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; Sha256HashProto &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aebb535adde7099f90ae8da5b9670d3ab">CreateSha256HashProto</a> (absl::string_view hash_hex)</td></tr>
<tr class="memdesc:aebb535adde7099f90ae8da5b9670d3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>Sha256HashProto</code> with the hash of the given |hash_hex|, or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if the provided string is an invalid hex-encoded SHA-256 hash.  <a href="#aebb535adde7099f90ae8da5b9670d3ab">More...</a><br /></td></tr>
<tr class="separator:aebb535adde7099f90ae8da5b9670d3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10bde933e306f1bce56bbc454289b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#af10bde933e306f1bce56bbc454289b18">ValidateSha256HashProto</a> (const Sha256HashProto &amp;hash_proto)</td></tr>
<tr class="memdesc:af10bde933e306f1bce56bbc454289b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates that |hash_proto| has a hash that is exactly 32 bytes.  <a href="#af10bde933e306f1bce56bbc454289b18">More...</a><br /></td></tr>
<tr class="separator:af10bde933e306f1bce56bbc454289b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51945598697c3b053fa6012c76b6b7e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a51945598697c3b053fa6012c76b6b7e7">operator==</a> (const Sha256HashProto &amp;lhs, const Sha256HashProto &amp;rhs)</td></tr>
<tr class="memdesc:a51945598697c3b053fa6012c76b6b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code>Sha256HashProto</code> messages for equality.  <a href="#a51945598697c3b053fa6012c76b6b7e7">More...</a><br /></td></tr>
<tr class="separator:a51945598697c3b053fa6012c76b6b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f73c209a6586e3f32086549ab16f57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ac6f73c209a6586e3f32086549ab16f57">operator!=</a> (const Sha256HashProto &amp;lhs, const Sha256HashProto &amp;rhs)</td></tr>
<tr class="memdesc:ac6f73c209a6586e3f32086549ab16f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code>Sha256HashProto</code> messages for inequality.  <a href="#ac6f73c209a6586e3f32086549ab16f57">More...</a><br /></td></tr>
<tr class="separator:ac6f73c209a6586e3f32086549ab16f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6172f61ca6679f7d266b9aebbbc5238b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::grpc::ChannelCredentials &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a> (<a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> options)</td></tr>
<tr class="memdesc:a6172f61ca6679f7d266b9aebbbc5238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>grpc::ChannelCredentials</code> object for use in an enclave system.  <a href="#a6172f61ca6679f7d266b9aebbbc5238b">More...</a><br /></td></tr>
<tr class="separator:a6172f61ca6679f7d266b9aebbbc5238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ae5afd47e724b67e79da0ef6d923fe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::grpc::ServerCredentials &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a> (<a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> options)</td></tr>
<tr class="memdesc:a41ae5afd47e724b67e79da0ef6d923fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>grpc::ServerCredentials</code> object for use in an enclave system.  <a href="#a41ae5afd47e724b67e79da0ef6d923fe">More...</a><br /></td></tr>
<tr class="separator:a41ae5afd47e724b67e79da0ef6d923fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6845bbc7c89b991bb89df0dd8cb628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#acb6845bbc7c89b991bb89df0dd8cb628">BidirectionalNullCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:acb6845bbc7c89b991bb89df0dd8cb628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a bidirectionally-unauthenticated gRPC channel between two enclave entities.  <a href="#acb6845bbc7c89b991bb89df0dd8cb628">More...</a><br /></td></tr>
<tr class="separator:acb6845bbc7c89b991bb89df0dd8cb628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4324ed0a8827c59ee3f737173be7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#acf4324ed0a8827c59ee3f737173be7fa">PeerNullCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:acf4324ed0a8827c59ee3f737173be7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-unauthenticated gRPC channel between two enclave entities.  <a href="#acf4324ed0a8827c59ee3f737173be7fa">More...</a><br /></td></tr>
<tr class="separator:acf4324ed0a8827c59ee3f737173be7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1196326488d3e0a06805d29ff9ccf52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ab1196326488d3e0a06805d29ff9ccf52">SelfNullCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:ab1196326488d3e0a06805d29ff9ccf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-unauthenticated gRPC channel between two enclave entities.  <a href="#ab1196326488d3e0a06805d29ff9ccf52">More...</a><br /></td></tr>
<tr class="separator:ab1196326488d3e0a06805d29ff9ccf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f89d61e86e7c51a77b268b1c68bf48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ae0f89d61e86e7c51a77b268b1c68bf48">PeerSgxAgeRemoteCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:ae0f89d61e86e7c51a77b268b1c68bf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel where it accepts identities attested by a remote SGX enclave using Asylo's Assertion Generator Enclave.  <a href="#ae0f89d61e86e7c51a77b268b1c68bf48">More...</a><br /></td></tr>
<tr class="separator:ae0f89d61e86e7c51a77b268b1c68bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65afd997f43db28cdffb6e2f1e851c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a65afd997f43db28cdffb6e2f1e851c7d">BidirectionalSgxAgeRemoteCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:a65afd997f43db28cdffb6e2f1e851c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a bidirectionally-authenticated gRPC channel between two SGX enclaves which each use Asylo's Assertion Generator Enclave.  <a href="#a65afd997f43db28cdffb6e2f1e851c7d">More...</a><br /></td></tr>
<tr class="separator:a65afd997f43db28cdffb6e2f1e851c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d92e7c2eacdf8539d0944dfcec62d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a81d92e7c2eacdf8539d0944dfcec62d8">SelfSgxAgeRemoteCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:a81d92e7c2eacdf8539d0944dfcec62d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel.  <a href="#a81d92e7c2eacdf8539d0944dfcec62d8">More...</a><br /></td></tr>
<tr class="separator:a81d92e7c2eacdf8539d0944dfcec62d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3491454b2415fc24fa03394354f09d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a3491454b2415fc24fa03394354f09d10">BidirectionalSgxLocalCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:a3491454b2415fc24fa03394354f09d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a bidirectionally-authenticated gRPC channel between two local SGX enclaves.  <a href="#a3491454b2415fc24fa03394354f09d10">More...</a><br /></td></tr>
<tr class="separator:a3491454b2415fc24fa03394354f09d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc68a49014050276695e89b190eab7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a8dc68a49014050276695e89b190eab7d">PeerSgxLocalCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:a8dc68a49014050276695e89b190eab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel between two local SGX enclaves.  <a href="#a8dc68a49014050276695e89b190eab7d">More...</a><br /></td></tr>
<tr class="separator:a8dc68a49014050276695e89b190eab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff2ebca6691694992b41a14fa8abc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a80ff2ebca6691694992b41a14fa8abc1">SelfSgxLocalCredentialsOptions</a> ()</td></tr>
<tr class="memdesc:a80ff2ebca6691694992b41a14fa8abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel between two local SGX enclaves.  <a href="#a80ff2ebca6691694992b41a14fa8abc1">More...</a><br /></td></tr>
<tr class="separator:a80ff2ebca6691694992b41a14fa8abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f115259e564d5ade4096cd5e3ecf05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aa6f115259e564d5ade4096cd5e3ecf05">SetNullAssertionDescription</a> (AssertionDescription *assertion_description)</td></tr>
<tr class="memdesc:aa6f115259e564d5ade4096cd5e3ecf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>assertion_description</code> to describe a null assertion.  <a href="#aa6f115259e564d5ade4096cd5e3ecf05">More...</a><br /></td></tr>
<tr class="separator:aa6f115259e564d5ade4096cd5e3ecf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e0cc85f971fa29aa075eeed43b772d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a84e0cc85f971fa29aa075eeed43b772d">SetNullIdentityDescription</a> (EnclaveIdentityDescription *identity_description)</td></tr>
<tr class="memdesc:a84e0cc85f971fa29aa075eeed43b772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>identity_description</code> to describe a null identity.  <a href="#a84e0cc85f971fa29aa075eeed43b772d">More...</a><br /></td></tr>
<tr class="separator:a84e0cc85f971fa29aa075eeed43b772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d12c2532052365108e2b59a466cfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a18d12c2532052365108e2b59a466cfce">SetSgxLocalAssertionDescription</a> (AssertionDescription *assertion_description)</td></tr>
<tr class="memdesc:a18d12c2532052365108e2b59a466cfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>assertion_description</code> to describe an SGX local assertion.  <a href="#a18d12c2532052365108e2b59a466cfce">More...</a><br /></td></tr>
<tr class="separator:a18d12c2532052365108e2b59a466cfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfcb13ce45083bea24d7a2dcba884f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a4cfcb13ce45083bea24d7a2dcba884f9">SetSgxAgeRemoteAssertionDescription</a> (AssertionDescription *assertion_description)</td></tr>
<tr class="memdesc:a4cfcb13ce45083bea24d7a2dcba884f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>assertion_description</code> to describe an SGX remote assertion generated by the Assertion Generator Enclave (AGE).  <a href="#a4cfcb13ce45083bea24d7a2dcba884f9">More...</a><br /></td></tr>
<tr class="separator:a4cfcb13ce45083bea24d7a2dcba884f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0133e34526b1df93bbbfb5382560d479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a0133e34526b1df93bbbfb5382560d479">SetSgxIntelEcdsaQeRemoteAssertionDescription</a> (AssertionDescription *assertion_description)</td></tr>
<tr class="memdesc:a0133e34526b1df93bbbfb5382560d479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>assertion_description</code> to describe an SGX remote assertion generated by the Intel ECDSA Quoting Enclave (QE).  <a href="#a0133e34526b1df93bbbfb5382560d479">More...</a><br /></td></tr>
<tr class="separator:a0133e34526b1df93bbbfb5382560d479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fbde1c34a3cbc7e847eac196fdf47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a2e4fbde1c34a3cbc7e847eac196fdf47">SetSgxIdentityDescription</a> (EnclaveIdentityDescription *identity_description)</td></tr>
<tr class="memdesc:a2e4fbde1c34a3cbc7e847eac196fdf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>identity_description</code> to describe an SGX identity.  <a href="#a2e4fbde1c34a3cbc7e847eac196fdf47">More...</a><br /></td></tr>
<tr class="separator:a2e4fbde1c34a3cbc7e847eac196fdf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88125b3707d0c495049e944fb1b2122a"><td class="memItemLeft" align="right" valign="top">EnclaveAssertionAuthorityConfig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a88125b3707d0c495049e944fb1b2122a">CreateNullAssertionAuthorityConfig</a> ()</td></tr>
<tr class="memdesc:a88125b3707d0c495049e944fb1b2122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a configuration for the null assertion authority.  <a href="#a88125b3707d0c495049e944fb1b2122a">More...</a><br /></td></tr>
<tr class="separator:a88125b3707d0c495049e944fb1b2122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac166310b0b726d04c9b42ded112ea66c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveAssertionAuthorityConfig &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ac166310b0b726d04c9b42ded112ea66c">CreateSgxLocalAssertionAuthorityConfig</a> (std::string attestation_domain)</td></tr>
<tr class="memdesc:ac166310b0b726d04c9b42ded112ea66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a configuration for the SGX local assertion authority.  <a href="#ac166310b0b726d04c9b42ded112ea66c">More...</a><br /></td></tr>
<tr class="separator:ac166310b0b726d04c9b42ded112ea66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3572ca5a070eb9393fa6aee1906c2b74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveAssertionAuthorityConfig &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a3572ca5a070eb9393fa6aee1906c2b74">CreateSgxLocalAssertionAuthorityConfig</a> ()</td></tr>
<tr class="memdesc:a3572ca5a070eb9393fa6aee1906c2b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a configuration for the SGX local assertion authority.  <a href="#a3572ca5a070eb9393fa6aee1906c2b74">More...</a><br /></td></tr>
<tr class="separator:a3572ca5a070eb9393fa6aee1906c2b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320068d1e4b8edcdf7f94a4cf2d96ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveAssertionAuthorityConfig &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a320068d1e4b8edcdf7f94a4cf2d96ef0">CreateSgxAgeRemoteAssertionAuthorityConfig</a> (Certificate intel_root_cert, std::vector&lt; Certificate &gt; certificates, std::string server_address, IdentityAclPredicate age_identity_expectation)</td></tr>
<tr class="memdesc:a320068d1e4b8edcdf7f94a4cf2d96ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a configuration for the SGX AGE remote assertion authority.  <a href="#a320068d1e4b8edcdf7f94a4cf2d96ef0">More...</a><br /></td></tr>
<tr class="separator:a320068d1e4b8edcdf7f94a4cf2d96ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ed081abf7ba7312e4c1b1b2c27dd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveAssertionAuthorityConfig &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad8ed081abf7ba7312e4c1b1b2c27dd62">CreateSgxAgeRemoteAssertionAuthorityConfig</a> (std::string server_address, SgxIdentity age_identity)</td></tr>
<tr class="memdesc:ad8ed081abf7ba7312e4c1b1b2c27dd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a configuration for the SGX AGE remote assertion authority.  <a href="#ad8ed081abf7ba7312e4c1b1b2c27dd62">More...</a><br /></td></tr>
<tr class="separator:ad8ed081abf7ba7312e4c1b1b2c27dd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b541071895273683819703beb78b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a559b541071895273683819703beb78b9">EvaluateIdentityAcl</a> (const std::vector&lt; EnclaveIdentity &gt; &amp;identities, const IdentityAclPredicate &amp;acl, const <a class="el" href="classasylo_1_1IdentityExpectationMatcher.html">IdentityExpectationMatcher</a> &amp;matcher, std::string *explanation=nullptr)</td></tr>
<tr class="memdesc:a559b541071895273683819703beb78b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses <code>matcher</code> to evaluate whether <code>identities</code> satisfies <code>acl</code>.  <a href="#a559b541071895273683819703beb78b9">More...</a><br /></td></tr>
<tr class="separator:a559b541071895273683819703beb78b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda794375993fd142bcfcacf9b41b0c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#adda794375993fd142bcfcacf9b41b0c1">DEFINE_STATIC_MAP_OF_BASE_TYPE</a> (IdentityExpectationMatcherMap, <a class="el" href="classasylo_1_1NamedIdentityExpectationMatcher.html">NamedIdentityExpectationMatcher</a>)</td></tr>
<tr class="separator:adda794375993fd142bcfcacf9b41b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb1acb66c35996d48d999435931d5f4"><td class="memItemLeft" align="right" valign="top">EnclaveIdentityExpectation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a5bb1acb66c35996d48d999435931d5f4">CreateNullIdentityExpectation</a> ()</td></tr>
<tr class="memdesc:a5bb1acb66c35996d48d999435931d5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default null identity expectation.  <a href="#a5bb1acb66c35996d48d999435931d5f4">More...</a><br /></td></tr>
<tr class="separator:a5bb1acb66c35996d48d999435931d5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89433d74e8a613ec3dd232172d787136"><td class="memItemLeft" align="right" valign="top">SgxIdentity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a89433d74e8a613ec3dd232172d787136">GetSelfSgxIdentity</a> ()</td></tr>
<tr class="memdesc:a89433d74e8a613ec3dd232172d787136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current enclave's identity.  <a href="#a89433d74e8a613ec3dd232172d787136">More...</a><br /></td></tr>
<tr class="separator:a89433d74e8a613ec3dd232172d787136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a059eec748ce444409556e72e35bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentityMatchSpec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a22a059eec748ce444409556e72e35bd6">CreateSgxIdentityMatchSpec</a> (<a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">SgxIdentityMatchSpecOptions</a> options)</td></tr>
<tr class="memdesc:a22a059eec748ce444409556e72e35bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>SgxIdentityMatchSpec</code> corresponding to <code>options</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#a22a059eec748ce444409556e72e35bd6">More...</a><br /></td></tr>
<tr class="separator:a22a059eec748ce444409556e72e35bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6ac352ae3f0b0a2caa5d611e32392b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentityExpectation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#abd6ac352ae3f0b0a2caa5d611e32392b">CreateSgxIdentityExpectation</a> (SgxIdentity identity, SgxIdentityMatchSpec match_spec)</td></tr>
<tr class="memdesc:abd6ac352ae3f0b0a2caa5d611e32392b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>SgxIdentityExpectation</code> formed from <code>identity</code> and <code>match_spec</code>, or returns a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if either are invalid or if they are incompatible with each other.  <a href="#abd6ac352ae3f0b0a2caa5d611e32392b">More...</a><br /></td></tr>
<tr class="separator:abd6ac352ae3f0b0a2caa5d611e32392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfcb5ff996e2fb15eb419fe4581305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentityExpectation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a2dfcb5ff996e2fb15eb419fe4581305e">CreateSgxIdentityExpectation</a> (SgxIdentity identity, <a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">SgxIdentityMatchSpecOptions</a> options)</td></tr>
<tr class="memdesc:a2dfcb5ff996e2fb15eb419fe4581305e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>SgxIdentityExpectation</code> formed from <code>identity</code> and the match spec corresponding to <code>options</code>, or returns a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if either are invalid or if they are incompatible with each other.  <a href="#a2dfcb5ff996e2fb15eb419fe4581305e">More...</a><br /></td></tr>
<tr class="separator:a2dfcb5ff996e2fb15eb419fe4581305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24349ac4d5ad2bfa238b23e85a88a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ab24349ac4d5ad2bfa238b23e85a88a4e">IsValidSgxIdentity</a> (const SgxIdentity &amp;identity)</td></tr>
<tr class="memdesc:ab24349ac4d5ad2bfa238b23e85a88a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>identity</code> is valid.  <a href="#ab24349ac4d5ad2bfa238b23e85a88a4e">More...</a><br /></td></tr>
<tr class="separator:ab24349ac4d5ad2bfa238b23e85a88a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979e85c5c97902ba0da13c7540de39b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a979e85c5c97902ba0da13c7540de39b3">IsValidSgxIdentityMatchSpec</a> (const SgxIdentityMatchSpec &amp;match_spec)</td></tr>
<tr class="memdesc:a979e85c5c97902ba0da13c7540de39b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>match_spec</code> is valid.  <a href="#a979e85c5c97902ba0da13c7540de39b3">More...</a><br /></td></tr>
<tr class="separator:a979e85c5c97902ba0da13c7540de39b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad214196603f517b9802eb36dd864b366"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad214196603f517b9802eb36dd864b366">IsValidSgxIdentityExpectation</a> (const SgxIdentityExpectation &amp;expectation)</td></tr>
<tr class="memdesc:ad214196603f517b9802eb36dd864b366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>expectation</code> is valid.  <a href="#ad214196603f517b9802eb36dd864b366">More...</a><br /></td></tr>
<tr class="separator:ad214196603f517b9802eb36dd864b366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cbff2754e89831a911951452430ac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentity &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad7cbff2754e89831a911951452430ac8">ParseSgxIdentity</a> (const EnclaveIdentity &amp;generic_identity)</td></tr>
<tr class="memdesc:ad7cbff2754e89831a911951452430ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses and validates <code>generic_identity</code>, returning an <code>SgxIdentity</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#ad7cbff2754e89831a911951452430ac8">More...</a><br /></td></tr>
<tr class="separator:ad7cbff2754e89831a911951452430ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad262c8c9df110767787290855411b96c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentityMatchSpec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad262c8c9df110767787290855411b96c">ParseSgxIdentityMatchSpec</a> (const std::string &amp;generic_match_spec)</td></tr>
<tr class="memdesc:ad262c8c9df110767787290855411b96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses and validates <code>generic_match_spec</code>, returning an <code>SgxIdentityMatchSpec</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#ad262c8c9df110767787290855411b96c">More...</a><br /></td></tr>
<tr class="separator:ad262c8c9df110767787290855411b96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bd3881e5d037fd647e9106fe21c40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; SgxIdentityExpectation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ab8bd3881e5d037fd647e9106fe21c40d">ParseSgxIdentityExpectation</a> (const EnclaveIdentityExpectation &amp;generic_expectation)</td></tr>
<tr class="memdesc:ab8bd3881e5d037fd647e9106fe21c40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses and validates <code>generic_expectation</code>, returning an <code>SgxIdentityExpectation</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#ab8bd3881e5d037fd647e9106fe21c40d">More...</a><br /></td></tr>
<tr class="separator:ab8bd3881e5d037fd647e9106fe21c40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd22a1bce025eaaa50373049e7ce5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveIdentity &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a1efd22a1bce025eaaa50373049e7ce5b">SerializeSgxIdentity</a> (const SgxIdentity &amp;sgx_identity)</td></tr>
<tr class="memdesc:a1efd22a1bce025eaaa50373049e7ce5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes <code>sgx_identity</code>, returning an <code>EnclaveIdentity</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#a1efd22a1bce025eaaa50373049e7ce5b">More...</a><br /></td></tr>
<tr class="separator:a1efd22a1bce025eaaa50373049e7ce5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b2a112de8fc90c2464a198c0b46a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a60b2a112de8fc90c2464a198c0b46a38">SerializeSgxIdentityMatchSpec</a> (const SgxIdentityMatchSpec &amp;sgx_match_spec)</td></tr>
<tr class="memdesc:a60b2a112de8fc90c2464a198c0b46a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes <code>sgx_match_spec</code>, returning a string on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#a60b2a112de8fc90c2464a198c0b46a38">More...</a><br /></td></tr>
<tr class="separator:a60b2a112de8fc90c2464a198c0b46a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ea453b59f2ef701998d8e1ecfdb1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; EnclaveIdentityExpectation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a8c6ea453b59f2ef701998d8e1ecfdb1e">SerializeSgxIdentityExpectation</a> (const SgxIdentityExpectation &amp;sgx_expectation)</td></tr>
<tr class="memdesc:a8c6ea453b59f2ef701998d8e1ecfdb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes <code>sgx_expectation</code>, returning an <code>EnclaveIdentityExpectation</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure.  <a href="#a8c6ea453b59f2ef701998d8e1ecfdb1e">More...</a><br /></td></tr>
<tr class="separator:a8c6ea453b59f2ef701998d8e1ecfdb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830e6ca210017926c6f21138da33a6a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a830e6ca210017926c6f21138da33a6a6">SetEnclaveConfigDefaults</a> (const HostConfig &amp;host_config, EnclaveConfig *config)</td></tr>
<tr class="separator:a830e6ca210017926c6f21138da33a6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8053438ddafe4f065854cdee4a42c907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a8053438ddafe4f065854cdee4a42c907">SetEnclaveConfigDefaults</a> (EnclaveConfig *config)</td></tr>
<tr class="memdesc:a8053438ddafe4f065854cdee4a42c907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets critical uninitialized fields in <code>config</code> to default values.  <a href="#a8053438ddafe4f065854cdee4a42c907">More...</a><br /></td></tr>
<tr class="separator:a8053438ddafe4f065854cdee4a42c907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b276873d75168630811ff0456901"><td class="memItemLeft" align="right" valign="top">EnclaveConfig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aceb4b276873d75168630811ff0456901">CreateDefaultEnclaveConfig</a> (const HostConfig &amp;host_config)</td></tr>
<tr class="separator:aceb4b276873d75168630811ff0456901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592607563d6205bc9dfe82deaf0a28e"><td class="memItemLeft" align="right" valign="top">EnclaveConfig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a7592607563d6205bc9dfe82deaf0a28e">CreateDefaultEnclaveConfig</a> ()</td></tr>
<tr class="memdesc:a7592607563d6205bc9dfe82deaf0a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an EnclaveConfig proto with critical fields initialize to default values.  <a href="#a7592607563d6205bc9dfe82deaf0a28e">More...</a><br /></td></tr>
<tr class="separator:a7592607563d6205bc9dfe82deaf0a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005bb1a1f2f6b589f32ff69440fa6bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1primitives_1_1Client.html">primitives::Client</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a005bb1a1f2f6b589f32ff69440fa6bf6">LoadEnclaveInChildProcess</a> (absl::string_view enclave_name, void *enclave_base_address, size_t enclave_size)</td></tr>
<tr class="separator:a005bb1a1f2f6b589f32ff69440fa6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0df277b8e6121d40882faf3c2bc44bb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ac0df277b8e6121d40882faf3c2bc44bb">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classasylo_1_1SharedName.html">SharedName</a> &amp;name)</td></tr>
<tr class="separator:ac0df277b8e6121d40882faf3c2bc44bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b37170344ec76d66e88cddfae8c234"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a12b37170344ec76d66e88cddfae8c234"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a12b37170344ec76d66e88cddfae8c234">MakeCheckOpValueString</a> (std::ostream *os, const std::nullptr_t &amp;p)</td></tr>
<tr class="separator:a12b37170344ec76d66e88cddfae8c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516088e3c0a326815df211461ad64d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a6516088e3c0a326815df211461ad64d0">set_vlog_level</a> (int level)</td></tr>
<tr class="memdesc:a6516088e3c0a326815df211461ad64d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosity threshold for VLOG.  <a href="#a6516088e3c0a326815df211461ad64d0">More...</a><br /></td></tr>
<tr class="separator:a6516088e3c0a326815df211461ad64d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c7f45ff18036824b30e1d315306cfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a93c7f45ff18036824b30e1d315306cfd">get_vlog_level</a> ()</td></tr>
<tr class="memdesc:a93c7f45ff18036824b30e1d315306cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the verbosity threshold for VLOG.  <a href="#a93c7f45ff18036824b30e1d315306cfd">More...</a><br /></td></tr>
<tr class="separator:a93c7f45ff18036824b30e1d315306cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718c2d6add34237eb404b06fe6694c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a718c2d6add34237eb404b06fe6694c18">set_log_directory</a> (const std::string &amp;log_directory)</td></tr>
<tr class="memdesc:a718c2d6add34237eb404b06fe6694c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the log directory, as specified when this enclave is initialized.  <a href="#a718c2d6add34237eb404b06fe6694c18">More...</a><br /></td></tr>
<tr class="separator:a718c2d6add34237eb404b06fe6694c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2644ab2a74b608e5d3f3e5b228d5ae"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a2b2644ab2a74b608e5d3f3e5b228d5ae">get_log_directory</a> ()</td></tr>
<tr class="memdesc:a2b2644ab2a74b608e5d3f3e5b228d5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the log directory that was specified when this enclave is initialized.  <a href="#a2b2644ab2a74b608e5d3f3e5b228d5ae">More...</a><br /></td></tr>
<tr class="separator:a2b2644ab2a74b608e5d3f3e5b228d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf29aaae59bd1a1fb9bbfb7a059e9ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a9bf29aaae59bd1a1fb9bbfb7a059e9ee">EnsureDirectory</a> (const char *path)</td></tr>
<tr class="memdesc:a9bf29aaae59bd1a1fb9bbfb7a059e9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the log directory to make sure it's accessible, and creates it if it does not exist.  <a href="#a9bf29aaae59bd1a1fb9bbfb7a059e9ee">More...</a><br /></td></tr>
<tr class="separator:a9bf29aaae59bd1a1fb9bbfb7a059e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e697759e6f0edf9926d7c4bda2e6f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a9e697759e6f0edf9926d7c4bda2e6f0b">InitLogging</a> (const char *directory, const char *file_name, int level)</td></tr>
<tr class="memdesc:a9e697759e6f0edf9926d7c4bda2e6f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes minimal logging library.  <a href="#a9e697759e6f0edf9926d7c4bda2e6f0b">More...</a><br /></td></tr>
<tr class="separator:a9e697759e6f0edf9926d7c4bda2e6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fcb0ae5791d14eb8ef1c3a405dd0b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51fcb0ae5791d14eb8ef1c3a405dd0b7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a51fcb0ae5791d14eb8ef1c3a405dd0b7">CheckNotNull</a> (const char *file, int line, const char *exprtext, T &amp;&amp;t)</td></tr>
<tr class="memdesc:a51fcb0ae5791d14eb8ef1c3a405dd0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs a message if the given value of type <code>T</code> is null, and then forwards the value.  <a href="#a51fcb0ae5791d14eb8ef1c3a405dd0b7">More...</a><br /></td></tr>
<tr class="separator:a51fcb0ae5791d14eb8ef1c3a405dd0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1fe9c46895980125695a1e727ff3f8"><td class="memItemLeft" align="right" valign="top">PolymorphicStatusMatcherType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aac1fe9c46895980125695a1e727ff3f8">PosixErrorIs</a> (int errnum)</td></tr>
<tr class="memdesc:aac1fe9c46895980125695a1e727ff3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>-like object that contains the given POSIX error.  <a href="#aac1fe9c46895980125695a1e727ff3f8">More...</a><br /></td></tr>
<tr class="separator:aac1fe9c46895980125695a1e727ff3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441880ecccdc19e349c3440f9425f041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a441880ecccdc19e349c3440f9425f041">PosixError</a> (int errnum, absl::string_view message=&quot;&quot;)</td></tr>
<tr class="memdesc:a441880ecccdc19e349c3440f9425f041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> representing a POSIX error.  <a href="#a441880ecccdc19e349c3440f9425f041">More...</a><br /></td></tr>
<tr class="separator:a441880ecccdc19e349c3440f9425f041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3c82fd8b95473782c8fe04afe8ec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#af6f3c82fd8b95473782c8fe04afe8ec0">LastPosixError</a> (absl::string_view message=&quot;&quot;)</td></tr>
<tr class="memdesc:af6f3c82fd8b95473782c8fe04afe8ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> representing the last POSIX error in this thread.  <a href="#af6f3c82fd8b95473782c8fe04afe8ec0">More...</a><br /></td></tr>
<tr class="separator:af6f3c82fd8b95473782c8fe04afe8ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd4414f3eaa7d805e74b46ece741f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#adcbd4414f3eaa7d805e74b46ece741f2">GetErrno</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;status)</td></tr>
<tr class="memdesc:adcbd4414f3eaa7d805e74b46ece741f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the POSIX error number that a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> represents, or zero if the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> does not represent a POSIX error.  <a href="#adcbd4414f3eaa7d805e74b46ece741f2">More...</a><br /></td></tr>
<tr class="separator:adcbd4414f3eaa7d805e74b46ece741f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182ee831ebf45362cfd24b7f95fc1682"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a182ee831ebf45362cfd24b7f95fc1682"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a182ee831ebf45362cfd24b7f95fc1682">AbslParseFlag</a> (absl::string_view text, T *flag, std::string *error)</td></tr>
<tr class="separator:a182ee831ebf45362cfd24b7f95fc1682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af662ba14197ae6b5f0cd4e76ffe63a42"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af662ba14197ae6b5f0cd4e76ffe63a42"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#af662ba14197ae6b5f0cd4e76ffe63a42">AbslUnparseFlag</a> (const T &amp;flag)</td></tr>
<tr class="separator:af662ba14197ae6b5f0cd4e76ffe63a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb05d614b80b0147ae4af78a32cd41d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aecb05d614b80b0147ae4af78a32cd41d">operator==</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;lhs, const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;rhs)</td></tr>
<tr class="separator:aecb05d614b80b0147ae4af78a32cd41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e4e1efb5467dfd7b4fabe4a857434"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a885e4e1efb5467dfd7b4fabe4a857434">operator!=</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;lhs, const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;rhs)</td></tr>
<tr class="separator:a885e4e1efb5467dfd7b4fabe4a857434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a811c63d3a350c781b7c87f9d425beb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a7a811c63d3a350c781b7c87f9d425beb">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;status)</td></tr>
<tr class="separator:a7a811c63d3a350c781b7c87f9d425beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814261808b042d355974f0bb3bb6171"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ae814261808b042d355974f0bb3bb6171">operator==</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;lhs, const absl::Status &amp;rhs)</td></tr>
<tr class="separator:ae814261808b042d355974f0bb3bb6171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd57e81f0af17cdc8c495216c9eb6104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#abd57e81f0af17cdc8c495216c9eb6104">operator!=</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;lhs, const absl::Status &amp;rhs)</td></tr>
<tr class="separator:abd57e81f0af17cdc8c495216c9eb6104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317f9316209abf6df326db0de2010c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a317f9316209abf6df326db0de2010c18">operator==</a> (const absl::Status &amp;lhs, const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;rhs)</td></tr>
<tr class="separator:a317f9316209abf6df326db0de2010c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e64bf30b8a2402b3f937397b0cbee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a73e64bf30b8a2402b3f937397b0cbee0">operator!=</a> (const absl::Status &amp;lhs, const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;rhs)</td></tr>
<tr class="separator:a73e64bf30b8a2402b3f937397b0cbee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03025d792be214c036d83424e26cd48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ac03025d792be214c036d83424e26cd48">OkStatus</a> ()</td></tr>
<tr class="memdesc:ac03025d792be214c036d83424e26cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an OK status object.  <a href="#ac03025d792be214c036d83424e26cd48">More...</a><br /></td></tr>
<tr class="separator:ac03025d792be214c036d83424e26cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6e2497ee5fd14756f9e2cc5e2fe12f"><td class="memTemplParams" colspan="2">template&lt;typename ToStatusT , typename FromStatusT &gt; </td></tr>
<tr class="memitem:aba6e2497ee5fd14756f9e2cc5e2fe12f"><td class="memTemplItemLeft" align="right" valign="top">ToStatusT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#aba6e2497ee5fd14756f9e2cc5e2fe12f">ConvertStatus</a> (const FromStatusT &amp;from_status)</td></tr>
<tr class="memdesc:aba6e2497ee5fd14756f9e2cc5e2fe12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a status-like object to another status type.  <a href="#aba6e2497ee5fd14756f9e2cc5e2fe12f">More...</a><br /></td></tr>
<tr class="separator:aba6e2497ee5fd14756f9e2cc5e2fe12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2dc8bbc3b091a862b6617ababd6334"><td class="memItemLeft" align="right" valign="top">StatusProto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a7b2dc8bbc3b091a862b6617ababd6334">StatusToProto</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;status)</td></tr>
<tr class="memdesc:a7b2dc8bbc3b091a862b6617ababd6334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the contents of <code>status</code> into a <code>StatusProto</code>.  <a href="#a7b2dc8bbc3b091a862b6617ababd6334">More...</a><br /></td></tr>
<tr class="separator:a7b2dc8bbc3b091a862b6617ababd6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0afce34d0ddf38d563a04267c1b922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ada0afce34d0ddf38d563a04267c1b922">StatusFromProto</a> (const StatusProto &amp;status_proto)</td></tr>
<tr class="memdesc:ada0afce34d0ddf38d563a04267c1b922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> based on the contents of the given <code>status_proto</code>.  <a href="#ada0afce34d0ddf38d563a04267c1b922">More...</a><br /></td></tr>
<tr class="separator:ada0afce34d0ddf38d563a04267c1b922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a08aabb13018a5ab5f799962159ba1"><td class="memTemplParams" colspan="2">template&lt;typename MessageT &gt; </td></tr>
<tr class="memitem:a79a08aabb13018a5ab5f799962159ba1"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a79a08aabb13018a5ab5f799962159ba1">GetTypeUrl</a> ()</td></tr>
<tr class="memdesc:a79a08aabb13018a5ab5f799962159ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type URL associated with a given protobuf message type.  <a href="#a79a08aabb13018a5ab5f799962159ba1">More...</a><br /></td></tr>
<tr class="separator:a79a08aabb13018a5ab5f799962159ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336a6e224ec5a68c150d0ed4af5c0e17"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename StatusT  = Status&gt; </td></tr>
<tr class="memitem:a336a6e224ec5a68c150d0ed4af5c0e17"><td class="memTemplItemLeft" align="right" valign="top">absl::optional&lt; MessageT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a336a6e224ec5a68c150d0ed4af5c0e17">GetProtoPayload</a> (const StatusT &amp;status)</td></tr>
<tr class="memdesc:a336a6e224ec5a68c150d0ed4af5c0e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the payload of type <code>MessageT</code> in <code>status</code>.  <a href="#a336a6e224ec5a68c150d0ed4af5c0e17">More...</a><br /></td></tr>
<tr class="separator:a336a6e224ec5a68c150d0ed4af5c0e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d5d9d0a8894a03cbfa23f3b69fd97"><td class="memTemplParams" colspan="2">template&lt;typename MessageT , typename StatusT  = Status&gt; </td></tr>
<tr class="memitem:a347d5d9d0a8894a03cbfa23f3b69fd97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a347d5d9d0a8894a03cbfa23f3b69fd97">SetProtoPayload</a> (const MessageT &amp;message, StatusT &amp;status)</td></tr>
<tr class="memdesc:a347d5d9d0a8894a03cbfa23f3b69fd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a payload of type <code>MessageT</code> to <code>status</code>.  <a href="#a347d5d9d0a8894a03cbfa23f3b69fd97">More...</a><br /></td></tr>
<tr class="separator:a347d5d9d0a8894a03cbfa23f3b69fd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ebb437b3c00856f9a9054ef47feb30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a59ebb437b3c00856f9a9054ef47feb30">WithContext</a> (const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;status, absl::string_view context)</td></tr>
<tr class="memdesc:a59ebb437b3c00856f9a9054ef47feb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> with the provided context prepended to its error message.  <a href="#a59ebb437b3c00856f9a9054ef47feb30">More...</a><br /></td></tr>
<tr class="separator:a59ebb437b3c00856f9a9054ef47feb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77584ecb42f762606be6cec5670bd5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad77584ecb42f762606be6cec5670bd5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ad77584ecb42f762606be6cec5670bd5f">WithContext</a> (<a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; T &gt; status_or, absl::string_view context)</td></tr>
<tr class="memdesc:ad77584ecb42f762606be6cec5670bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">As the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> overload above, but for <code><a class="el" href="classasylo_1_1StatusOr.html" title="A class for representing either a usable value, or an error. ">StatusOr</a>&lt;T&gt;</code>.  <a href="#ad77584ecb42f762606be6cec5670bd5f">More...</a><br /></td></tr>
<tr class="separator:ad77584ecb42f762606be6cec5670bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f0d204d1c203d43bb8181b5a95095a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9f0d204d1c203d43bb8181b5a95095a"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ae9f0d204d1c203d43bb8181b5a95095a">WithContext</a> (absl::StatusOr&lt; T &gt; status_or, absl::string_view context)</td></tr>
<tr class="memdesc:ae9f0d204d1c203d43bb8181b5a95095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As the <code><a class="el" href="classasylo_1_1StatusOr.html" title="A class for representing either a usable value, or an error. ">StatusOr</a>&lt;T&gt;</code> overload above, but for <code>absl::StatusOr&lt;T&gt;</code>.  <a href="#ae9f0d204d1c203d43bb8181b5a95095a">More...</a><br /></td></tr>
<tr class="separator:ae9f0d204d1c203d43bb8181b5a95095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3761b184f111021d5bbee1139d21a7b9"><td class="memItemLeft" align="right" valign="top">ABSL_CONST_INIT const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a3761b184f111021d5bbee1139d21a7b9">kValueMoveConstructorMsg</a> []</td></tr>
<tr class="separator:a3761b184f111021d5bbee1139d21a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5996a0b819b65f1a8d281beb8f4fff"><td class="memItemLeft" align="right" valign="top">ABSL_CONST_INIT const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a6b5996a0b819b65f1a8d281beb8f4fff">kValueMoveAssignmentMsg</a> []</td></tr>
<tr class="separator:a6b5996a0b819b65f1a8d281beb8f4fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c326357c7452aac96ee0e128dd0e6"><td class="memItemLeft" align="right" valign="top">ABSL_CONST_INIT const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#ab65c326357c7452aac96ee0e128dd0e6">kValueOrDieMovedMsg</a> []</td></tr>
<tr class="separator:ab65c326357c7452aac96ee0e128dd0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd5688a45e23af3310b88489b7def41"><td class="memItemLeft" align="right" valign="top">ABSL_CONST_INIT const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#affd5688a45e23af3310b88489b7def41">kStatusMoveConstructorMsg</a> []</td></tr>
<tr class="separator:affd5688a45e23af3310b88489b7def41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fac12ece837aca860004ddc0eecd5df"><td class="memItemLeft" align="right" valign="top">ABSL_CONST_INIT const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasylo.html#a4fac12ece837aca860004ddc0eecd5df">kStatusMoveAssignmentMsg</a> []</td></tr>
<tr class="separator:a4fac12ece837aca860004ddc0eecd5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a135dc48e2850e970403849e585300222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135dc48e2850e970403849e585300222">&#9670;&nbsp;</a></span>CleansingString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasylo.html#a135dc48e2850e970403849e585300222">asylo::CleansingString</a> = typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, CleansingAllocator&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string that zeros its memory on free. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use <code>CleansingVector</code> instead. </dd></dl>

</div>
</div>
<a id="a9aec28a454f8e329b3cd81ef525ea753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aec28a454f8e329b3cd81ef525ea753">&#9670;&nbsp;</a></span>CleansingVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceasylo.html#a9aec28a454f8e329b3cd81ef525ea753">asylo::CleansingVector</a> = typedef std::vector&lt;T, CleansingAllocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector container that zeros its memory on free. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad9ce7785495cca99df26647b7762dcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ce7785495cca99df26647b7762dcbd">&#9670;&nbsp;</a></span>SgxIdentityMatchSpecOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">asylo::SgxIdentityMatchSpecOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum defines a set of recommended match specs. </p>
<p>Users are advised to pick the one that most closely matches their application's security requirements and make adjustments to these match specs as needed.</p>
<h3><code>DEFAULT</code></h3>
<ul>
<li>Requires a match on MRSIGNER, all MISCSELECT bits, and all ATTRIBUTES bits that are considered security-critical by default.</li>
<li>Does not require a match on any <code>sgx::MachineConfiguration</code> fields.</li>
</ul>
<h3><code>STRICT_LOCAL</code></h3>
<ul>
<li>Requires a match on MRENCLAVE, MRSIGNER, all MISCSELECT bits, and all ATTRIBUTES bits.</li>
<li>Requires a match on CPUSVN.<ul>
<li>Note that no other <code>sgx::MachineConfiguration</code> fields are required to match, as they are unavailable in local attestation. <h3><code>STRICT_REMOTE</code></h3>
</li>
</ul>
</li>
<li>Equivalent to the <code>STRICT_LOCAL</code> match spec, with the added requirement of matching all <code>sgx::MachineConfiguration</code> fields (not just CPUSVN). </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad9ce7785495cca99df26647b7762dcbda5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad9ce7785495cca99df26647b7762dcbdac2d5dca3ad8552b2447b19b538b93584"></a>STRICT_LOCAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad9ce7785495cca99df26647b7762dcbda6f0a9f12a74dedb34630ba69fc4d67e7"></a>STRICT_REMOTE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a182ee831ebf45362cfd24b7f95fc1682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182ee831ebf45362cfd24b7f95fc1682">&#9670;&nbsp;</a></span>AbslParseFlag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::AbslParseFlag </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af662ba14197ae6b5f0cd4e76ffe63a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af662ba14197ae6b5f0cd4e76ffe63a42">&#9670;&nbsp;</a></span>AbslUnparseFlag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string asylo::AbslUnparseFlag </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb6845bbc7c89b991bb89df0dd8cb628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6845bbc7c89b991bb89df0dd8cb628">&#9670;&nbsp;</a></span>BidirectionalNullCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::BidirectionalNullCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a bidirectionally-unauthenticated gRPC channel between two enclave entities. </p>
<p>A credential configured with these options enforces bidirectional authentication using the null identity. The null identity specifies no identity in particular, which means that the resulting connection is essentially unauthenticated.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#acb6845bbc7c89b991bb89df0dd8cb628">BidirectionalNullCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#acb6845bbc7c89b991bb89df0dd8cb628">BidirectionalNullCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a bidirectionally-unauthenticated channel. </dd></dl>

</div>
</div>
<a id="a65afd997f43db28cdffb6e2f1e851c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65afd997f43db28cdffb6e2f1e851c7d">&#9670;&nbsp;</a></span>BidirectionalSgxAgeRemoteCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::BidirectionalSgxAgeRemoteCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a bidirectionally-authenticated gRPC channel between two SGX enclaves which each use Asylo's Assertion Generator Enclave. </p>
<p>A credential configured with these options enforces bidirectional authentication using SGX enclave code identity.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#a65afd997f43db28cdffb6e2f1e851c7d">BidirectionalSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#a65afd997f43db28cdffb6e2f1e851c7d">BidirectionalSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a bidirectionally-authenticated channel between SGX enclaves. </dd></dl>

</div>
</div>
<a id="a3491454b2415fc24fa03394354f09d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3491454b2415fc24fa03394354f09d10">&#9670;&nbsp;</a></span>BidirectionalSgxLocalCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::BidirectionalSgxLocalCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a bidirectionally-authenticated gRPC channel between two local SGX enclaves. </p>
<p>A credential configured with these options enforces bidirectional authentication using SGX enclave code identity.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#a3491454b2415fc24fa03394354f09d10">BidirectionalSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#a3491454b2415fc24fa03394354f09d10">BidirectionalSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a bidirectionally-authenticated channel between SGX enclaves on the same platform. </dd></dl>

</div>
</div>
<a id="a51fcb0ae5791d14eb8ef1c3a405dd0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fcb0ae5791d14eb8ef1c3a405dd0b7">&#9670;&nbsp;</a></span>CheckNotNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T asylo::CheckNotNull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>exprtext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs a message if the given value of type <code>T</code> is null, and then forwards the value. </p>
<p>In C++11, all cases can be handled by a single function. Since the value category of the argument is preserved (also for rvalue references), member initializer lists like the one below will compile correctly:</p>
<div class="fragment"><div class="line">Foo()</div><div class="line">  : x_(<a class="code" href="logging_8h.html#ab4f4dc044a2ed1eb76fac50c769973fa">CHECK_NOTNULL</a>(MethodReturningUniquePtr())) {}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The source file that produced the log. </td></tr>
    <tr><td class="paramname">line</td><td>The source code line that produced the log. </td></tr>
    <tr><td class="paramname">exprtext</td><td>A string representation of the code in <code>file</code> at <code>line</code>. </td></tr>
    <tr><td class="paramname">t</td><td>The parameter being checked for null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6e2497ee5fd14756f9e2cc5e2fe12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6e2497ee5fd14756f9e2cc5e2fe12f">&#9670;&nbsp;</a></span>ConvertStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ToStatusT , typename FromStatusT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ToStatusT asylo::ConvertStatus </td>
          <td>(</td>
          <td class="paramtype">const FromStatusT &amp;&#160;</td>
          <td class="paramname"><em>from_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a status-like object to another status type. </p>
<p>The source and target types must:</p>
<ul>
<li>Have a two-parameter constructor that takes an enum as its first parameter and a string as its second parameter.</li>
<li>Have non-static <code>const</code> <code>error_code()</code>, <code>error_message()</code>, and <code>ok()</code> methods.</li>
</ul>
<p>This function is provided for the convenience of Asylo-SDK consumers utilizing other status types such as <code>::grpc::Status</code>.</p>
<p>Note that all statuses are converted to the canonical error space, so additional error space information is lost.</p>
<p>Payloads are preserved if both input and output status types support them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_status</td><td>A status-like object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status-like object copied from <code>from_status</code>. </dd></dl>

</div>
</div>
<a id="aceb4b276873d75168630811ff0456901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb4b276873d75168630811ff0456901">&#9670;&nbsp;</a></span>CreateDefaultEnclaveConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EnclaveConfig asylo::CreateDefaultEnclaveConfig </td>
          <td>(</td>
          <td class="paramtype">const HostConfig &amp;&#160;</td>
          <td class="paramname"><em>host_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Returns an EnclaveConfig proto with critical fields initialized to default values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_config</td><td>This parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An EnclaveConfig proto with critical fields initialized to their default values. </dd></dl>

</div>
</div>
<a id="a7592607563d6205bc9dfe82deaf0a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592607563d6205bc9dfe82deaf0a28e">&#9670;&nbsp;</a></span>CreateDefaultEnclaveConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EnclaveConfig asylo::CreateDefaultEnclaveConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an EnclaveConfig proto with critical fields initialize to default values. </p>
<dl class="section return"><dt>Returns</dt><dd>An EnclaveConfig proto with critical fields initialized to their default values. </dd></dl>

</div>
</div>
<a id="a88125b3707d0c495049e944fb1b2122a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88125b3707d0c495049e944fb1b2122a">&#9670;&nbsp;</a></span>CreateNullAssertionAuthorityConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EnclaveAssertionAuthorityConfig asylo::CreateNullAssertionAuthorityConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a configuration for the null assertion authority. </p>
<p>This configuration is required when using the <a class="el" href="classasylo_1_1NullAssertionGenerator.html" title="An implementation of the EnclaveAssertionGenerator interface for null assertions. ...">NullAssertionGenerator</a> or <a class="el" href="classasylo_1_1NullAssertionVerifier.html" title="An implementation of the EnclaveAssertionVerifier interface for null assertions. ">NullAssertionVerifier</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A config for the null assertion authority. </dd></dl>

</div>
</div>
<a id="a5bb1acb66c35996d48d999435931d5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb1acb66c35996d48d999435931d5f4">&#9670;&nbsp;</a></span>CreateNullIdentityExpectation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EnclaveIdentityExpectation asylo::CreateNullIdentityExpectation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a default null identity expectation. </p>

</div>
</div>
<a id="a320068d1e4b8edcdf7f94a4cf2d96ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320068d1e4b8edcdf7f94a4cf2d96ef0">&#9670;&nbsp;</a></span>CreateSgxAgeRemoteAssertionAuthorityConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveAssertionAuthorityConfig&gt; asylo::CreateSgxAgeRemoteAssertionAuthorityConfig </td>
          <td>(</td>
          <td class="paramtype">Certificate&#160;</td>
          <td class="paramname"><em>intel_root_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Certificate &gt;&#160;</td>
          <td class="paramname"><em>certificates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>server_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdentityAclPredicate&#160;</td>
          <td class="paramname"><em>age_identity_expectation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a configuration for the SGX AGE remote assertion authority. </p>
<p>This configuration is required when using the <a class="el" href="classasylo_1_1SgxAgeRemoteAssertionGenerator.html" title="A thread-safe implementation of the EnclaveAssertionGenerator interface for SGX remote assertions gen...">SgxAgeRemoteAssertionGenerator</a> or <a class="el" href="classasylo_1_1SgxAgeRemoteAssertionVerifier.html" title="An implemention of the EnclaveAssertionVerifier interface for SGX remote assertions generated by the ...">SgxAgeRemoteAssertionVerifier</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intel_cert</td><td>The Intel root certificate to use for verification. </td></tr>
    <tr><td class="paramname">certificates</td><td>A vector of X.509-formatted CA certificates that can be used to verify whether an assertion is valid. </td></tr>
    <tr><td class="paramname">server_address</td><td>The address of the AGE's service. </td></tr>
    <tr><td class="paramname">age_identity_expectation</td><td>The identity expectation for the AGE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A config for the SGX AGE remote assertion authority. </dd></dl>

</div>
</div>
<a id="ad8ed081abf7ba7312e4c1b1b2c27dd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ed081abf7ba7312e4c1b1b2c27dd62">&#9670;&nbsp;</a></span>CreateSgxAgeRemoteAssertionAuthorityConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveAssertionAuthorityConfig&gt; asylo::CreateSgxAgeRemoteAssertionAuthorityConfig </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>server_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SgxIdentity&#160;</td>
          <td class="paramname"><em>age_identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a configuration for the SGX AGE remote assertion authority. </p>
<p>This configuration is required when using the <a class="el" href="classasylo_1_1SgxAgeRemoteAssertionGenerator.html" title="A thread-safe implementation of the EnclaveAssertionGenerator interface for SGX remote assertions gen...">SgxAgeRemoteAssertionGenerator</a> or <a class="el" href="classasylo_1_1SgxAgeRemoteAssertionVerifier.html" title="An implemention of the EnclaveAssertionVerifier interface for SGX remote assertions generated by the ...">SgxAgeRemoteAssertionVerifier</a>. It uses the Intel root certificate value |kIntelSgxRootCaCertificate| and no additional root certificates. It sets the AGE identity expectation to the default expectation of the given SgxIdentity, as documented by <code>SgxIdentityMatchSpecOptions</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server_address</td><td>The address of the AGE's service. </td></tr>
    <tr><td class="paramname">age_identity</td><td>The expected identity of the AGE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A config for the SGX AGE remote assertion authority. </dd></dl>

</div>
</div>
<a id="abd6ac352ae3f0b0a2caa5d611e32392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6ac352ae3f0b0a2caa5d611e32392b">&#9670;&nbsp;</a></span>CreateSgxIdentityExpectation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentityExpectation&gt; asylo::CreateSgxIdentityExpectation </td>
          <td>(</td>
          <td class="paramtype">SgxIdentity&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SgxIdentityMatchSpec&#160;</td>
          <td class="paramname"><em>match_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <code>SgxIdentityExpectation</code> formed from <code>identity</code> and <code>match_spec</code>, or returns a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if either are invalid or if they are incompatible with each other. </p>

</div>
</div>
<a id="a2dfcb5ff996e2fb15eb419fe4581305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfcb5ff996e2fb15eb419fe4581305e">&#9670;&nbsp;</a></span>CreateSgxIdentityExpectation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentityExpectation&gt; asylo::CreateSgxIdentityExpectation </td>
          <td>(</td>
          <td class="paramtype">SgxIdentity&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">SgxIdentityMatchSpecOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <code>SgxIdentityExpectation</code> formed from <code>identity</code> and the match spec corresponding to <code>options</code>, or returns a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if either are invalid or if they are incompatible with each other. </p>

</div>
</div>
<a id="a22a059eec748ce444409556e72e35bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a059eec748ce444409556e72e35bd6">&#9670;&nbsp;</a></span>CreateSgxIdentityMatchSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentityMatchSpec&gt; asylo::CreateSgxIdentityMatchSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceasylo.html#ad9ce7785495cca99df26647b7762dcbd">SgxIdentityMatchSpecOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <code>SgxIdentityMatchSpec</code> corresponding to <code>options</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="ac166310b0b726d04c9b42ded112ea66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac166310b0b726d04c9b42ded112ea66c">&#9670;&nbsp;</a></span>CreateSgxLocalAssertionAuthorityConfig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveAssertionAuthorityConfig&gt; asylo::CreateSgxLocalAssertionAuthorityConfig </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attestation_domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a configuration for the SGX local assertion authority. </p>
<p>This configuration is required when using the <a class="el" href="classasylo_1_1SgxLocalAssertionGenerator.html" title="An implementation of the EnclaveAssertionGenerator interface for SGX local assertions. ">SgxLocalAssertionGenerator</a> or <a class="el" href="classasylo_1_1SgxLocalAssertionVerifier.html" title="An implemention of the EnclaveAssertionVerifier interface for SGX local assertions. ">SgxLocalAssertionVerifier</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attestation_domain</td><td>A 16-byte unique identifier for the SGX machine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A config for the SGX local assertion authority. </dd></dl>

</div>
</div>
<a id="a3572ca5a070eb9393fa6aee1906c2b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3572ca5a070eb9393fa6aee1906c2b74">&#9670;&nbsp;</a></span>CreateSgxLocalAssertionAuthorityConfig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveAssertionAuthorityConfig&gt; asylo::CreateSgxLocalAssertionAuthorityConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a configuration for the SGX local assertion authority. </p>
<p>The attestation domain is derived from the per-boot machine UUID in /proc/sys/kernel/random/boot_id.</p>
<p>This configuration is required when using the <a class="el" href="classasylo_1_1SgxLocalAssertionGenerator.html" title="An implementation of the EnclaveAssertionGenerator interface for SGX local assertions. ">SgxLocalAssertionGenerator</a> or <a class="el" href="classasylo_1_1SgxLocalAssertionVerifier.html" title="An implemention of the EnclaveAssertionVerifier interface for SGX local assertions. ">SgxLocalAssertionVerifier</a>.</p>
<p>/return A config for the SGX local assertion authority. </p>

</div>
</div>
<a id="aebb535adde7099f90ae8da5b9670d3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb535adde7099f90ae8da5b9670d3ab">&#9670;&nbsp;</a></span>CreateSha256HashProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;Sha256HashProto&gt; asylo::CreateSha256HashProto </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>hash_hex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>Sha256HashProto</code> with the hash of the given |hash_hex|, or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if the provided string is an invalid hex-encoded SHA-256 hash. </p>

</div>
</div>
<a id="adda794375993fd142bcfcacf9b41b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda794375993fd142bcfcacf9b41b0c1">&#9670;&nbsp;</a></span>DEFINE_STATIC_MAP_OF_BASE_TYPE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asylo::DEFINE_STATIC_MAP_OF_BASE_TYPE </td>
          <td>(</td>
          <td class="paramtype">IdentityExpectationMatcherMap&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasylo_1_1NamedIdentityExpectationMatcher.html">NamedIdentityExpectationMatcher</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6172f61ca6679f7d266b9aebbbc5238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6172f61ca6679f7d266b9aebbbc5238b">&#9670;&nbsp;</a></span>EnclaveChannelCredentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; asylo::EnclaveChannelCredentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <code>grpc::ChannelCredentials</code> object for use in an enclave system. </p>
<p>The configuration <code>options</code> determines which assertions are presented by the entity that wields the resulting credentials object. <code>options</code> must meet the following criteria:</p>
<ul>
<li><code>options.self_assertions</code> must contain at least one assertion description.</li>
<li><code>options.accepted_peer_assertions</code> must contain at least one assertion description.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Options for configuring the credentials. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A gRPC channel credentials object. </dd></dl>

</div>
</div>
<a id="a41ae5afd47e724b67e79da0ef6d923fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ae5afd47e724b67e79da0ef6d923fe">&#9670;&nbsp;</a></span>EnclaveServerCredentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::grpc::ServerCredentials&gt; asylo::EnclaveServerCredentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <code>grpc::ServerCredentials</code> object for use in an enclave system. </p>
<p>The configuration <code>options</code> determines which assertions are presented by the entity that wields the resulting credentials object. <code>options</code> must meet the following criteria:</p>
<ul>
<li><code>options.self_assertions</code> must contain at least one assertion description</li>
<li><code>options.accepted_peer_assertions</code> must contain at least one assertion description</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Options for configuring the credentials. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A gRPC server credentials object. </dd></dl>

</div>
</div>
<a id="a9bf29aaae59bd1a1fb9bbfb7a059e9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf29aaae59bd1a1fb9bbfb7a059e9ee">&#9670;&nbsp;</a></span>EnsureDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::EnsureDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the log directory to make sure it's accessible, and creates it if it does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The directory to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a559b541071895273683819703beb78b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b541071895273683819703beb78b9">&#9670;&nbsp;</a></span>EvaluateIdentityAcl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;bool&gt; asylo::EvaluateIdentityAcl </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; EnclaveIdentity &gt; &amp;&#160;</td>
          <td class="paramname"><em>identities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdentityAclPredicate &amp;&#160;</td>
          <td class="paramname"><em>acl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1IdentityExpectationMatcher.html">IdentityExpectationMatcher</a> &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>explanation</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses <code>matcher</code> to evaluate whether <code>identities</code> satisfies <code>acl</code>. </p>
<p>The ACL is provided in the form of an <code>IdentityAclPredicate</code>. An <code>IdentityAclPredicate</code> is a recursive proto, each layer of which must conform to the following constraints:</p>
<ul>
<li>A nested IdentityAclPredicate <code>predicate</code> must have <code>predicate.item</code> set.</li>
<li>A nested IdentityAclGroup <code>group</code> must have a non-empty <code>group.predicates</code>.<ul>
<li>If <code>group</code>.type is <code>GroupType::NOT</code>, <code>group.predicates</code> must contain exactly one predicate.</li>
</ul>
</li>
</ul>
<p>Returns a non-OK status if <code>acl</code> is malformed or if <code>matcher.MatchAndExplain()</code> returns a non-OK status when invoked with any of <code>identities</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">identities</td><td>A list of identities to match against the ACL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">acl</td><td>An ACL specifying expectations on an identity. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">matcher</td><td>The matcher to use to evaluate <code>identities</code> against <code>acl</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">explanation</td><td>An explanation of why the match failed, if the result is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the ACL evaluated to true, or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if any if the inputs are invalid. </dd></dl>

</div>
</div>
<a id="a2b2644ab2a74b608e5d3f3e5b228d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2644ab2a74b608e5d3f3e5b228d5ae">&#9670;&nbsp;</a></span>get_log_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string asylo::get_log_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the log directory that was specified when this enclave is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>The directory where the log files will be. </dd></dl>

</div>
</div>
<a id="a93c7f45ff18036824b30e1d315306cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c7f45ff18036824b30e1d315306cfd">&#9670;&nbsp;</a></span>get_vlog_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int asylo::get_vlog_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the verbosity threshold for VLOG. </p>
<p>A VLOG command with a level greater than this will be ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>The current verbosity threshold for VLOG. </dd></dl>

</div>
</div>
<a id="adcbd4414f3eaa7d805e74b46ece741f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbd4414f3eaa7d805e74b46ece741f2">&#9670;&nbsp;</a></span>GetErrno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int asylo::GetErrno </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the POSIX error number that a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> represents, or zero if the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> does not represent a POSIX error. </p>
<p>This function understands <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>es that were created in the POSIX error space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>A status object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The POSIX error number represented by <code>status</code>, or zero if <code>status</code> does not represent a POSIX error. </dd></dl>

</div>
</div>
<a id="a336a6e224ec5a68c150d0ed4af5c0e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336a6e224ec5a68c150d0ed4af5c0e17">&#9670;&nbsp;</a></span>GetProtoPayload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename StatusT  = Status&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt;MessageT&gt; asylo::GetProtoPayload </td>
          <td>(</td>
          <td class="paramtype">const StatusT &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the payload of type <code>MessageT</code> in <code>status</code>. </p>
<p><code>MessageT</code> must be a protobuf message type.</p>
<p>The <code>status</code> argument may be either an Asylo <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> or an <code>absl::Status</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The status to find the payload in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The payload of type <code>MessageT</code> in <code>status</code>, or <code>absl::nullopt</code> if <code>status</code> contains no payload of the given type. Also returns <code>absl::nullopt</code> if there was a parsing error. </dd></dl>

</div>
</div>
<a id="a89433d74e8a613ec3dd232172d787136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89433d74e8a613ec3dd232172d787136">&#9670;&nbsp;</a></span>GetSelfSgxIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgxIdentity asylo::GetSelfSgxIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current enclave's identity. </p>

</div>
</div>
<a id="a79a08aabb13018a5ab5f799962159ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a08aabb13018a5ab5f799962159ba1">&#9670;&nbsp;</a></span>GetTypeUrl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string asylo::GetTypeUrl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type URL associated with a given protobuf message type. </p>
<p>This should be used when embedding a message of that type as a payload in a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The type URL to use for <code>MessageT</code> payloads. </dd></dl>

</div>
</div>
<a id="a9e697759e6f0edf9926d7c4bda2e6f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e697759e6f0edf9926d7c4bda2e6f0b">&#9670;&nbsp;</a></span>InitLogging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::InitLogging </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes minimal logging library. </p>
<p>For untrusted logging, the program name specified by argv0 will be used as log filename; For enclave logging, the enclave name will be used as log filename (any slashes or dots will be removed). This method is called during enclave initialization. For untrusted logging, this should be called in main().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The log file directory. </td></tr>
    <tr><td class="paramname">file_name</td><td>The name of the log file. </td></tr>
    <tr><td class="paramname">level</td><td>The verbosity threshold for VLOG commands. A VLOG command with a level equal to or lower than it will be logged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24349ac4d5ad2bfa238b23e85a88a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24349ac4d5ad2bfa238b23e85a88a4e">&#9670;&nbsp;</a></span>IsValidSgxIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::IsValidSgxIdentity </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentity &amp;&#160;</td>
          <td class="paramname"><em>identity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether <code>identity</code> is valid. </p>
<p>An <code>SgxIdentity</code> is considered valid if its MISCSELECT and ATTRIBUTES properties are set and any additional fields present in the message are valid as well. </p>

</div>
</div>
<a id="ad214196603f517b9802eb36dd864b366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad214196603f517b9802eb36dd864b366">&#9670;&nbsp;</a></span>IsValidSgxIdentityExpectation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::IsValidSgxIdentityExpectation </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentityExpectation &amp;&#160;</td>
          <td class="paramname"><em>expectation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether <code>expectation</code> is valid. </p>
<p>An <code>SgxIdentityExpectation</code> is valid if its identity and match spec components are valid and they are both compatible with each other. </p>

</div>
</div>
<a id="a979e85c5c97902ba0da13c7540de39b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979e85c5c97902ba0da13c7540de39b3">&#9670;&nbsp;</a></span>IsValidSgxIdentityMatchSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::IsValidSgxIdentityMatchSpec </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentityMatchSpec &amp;&#160;</td>
          <td class="paramname"><em>match_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether <code>match_spec</code> is valid. </p>
<p>An <code>SgxIdentityMatchSpec</code> is valid if all of its constituent fields are set. </p>

</div>
</div>
<a id="af6f3c82fd8b95473782c8fe04afe8ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3c82fd8b95473782c8fe04afe8ec0">&#9670;&nbsp;</a></span>LastPosixError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::LastPosixError </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>message</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> representing the last POSIX error in this thread. </p>
<p>Equivalent to calling <code>PosixError(errno, message)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>An optional message to prepend to the POSIX error explanation string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error the last POSIX error in this thread. </dd></dl>

</div>
</div>
<a id="a005bb1a1f2f6b589f32ff69440fa6bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005bb1a1f2f6b589f32ff69440fa6bf6">&#9670;&nbsp;</a></span>LoadEnclaveInChildProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1primitives_1_1Client.html">primitives::Client</a>* asylo::LoadEnclaveInChildProcess </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>enclave_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enclave_base_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>enclave_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12b37170344ec76d66e88cddfae8c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b37170344ec76d66e88cddfae8c234">&#9670;&nbsp;</a></span>MakeCheckOpValueString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asylo::MakeCheckOpValueString </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac03025d792be214c036d83424e26cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03025d792be214c036d83424e26cd48">&#9670;&nbsp;</a></span>OkStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::OkStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an OK status object. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> indicating no error occurred. </dd></dl>

</div>
</div>
<a id="ac6f73c209a6586e3f32086549ab16f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f73c209a6586e3f32086549ab16f57">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Sha256HashProto &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sha256HashProto &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <code>Sha256HashProto</code> messages for inequality. </p>

</div>
</div>
<a id="a885e4e1efb5467dfd7b4fabe4a857434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885e4e1efb5467dfd7b4fabe4a857434">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd57e81f0af17cdc8c495216c9eb6104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd57e81f0af17cdc8c495216c9eb6104">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Status &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73e64bf30b8a2402b3f937397b0cbee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e64bf30b8a2402b3f937397b0cbee0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator!= </td>
          <td>(</td>
          <td class="paramtype">const absl::Status &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0df277b8e6121d40882faf3c2bc44bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0df277b8e6121d40882faf3c2bc44bb">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; asylo::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1SharedName.html">SharedName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a811c63d3a350c781b7c87f9d425beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a811c63d3a350c781b7c87f9d425beb">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; asylo::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51945598697c3b053fa6012c76b6b7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51945598697c3b053fa6012c76b6b7e7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator== </td>
          <td>(</td>
          <td class="paramtype">const Sha256HashProto &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sha256HashProto &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <code>Sha256HashProto</code> messages for equality. </p>

</div>
</div>
<a id="aecb05d614b80b0147ae4af78a32cd41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb05d614b80b0147ae4af78a32cd41d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae814261808b042d355974f0bb3bb6171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814261808b042d355974f0bb3bb6171">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Status &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a317f9316209abf6df326db0de2010c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317f9316209abf6df326db0de2010c18">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::operator== </td>
          <td>(</td>
          <td class="paramtype">const absl::Status &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7cbff2754e89831a911951452430ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cbff2754e89831a911951452430ac8">&#9670;&nbsp;</a></span>ParseSgxIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentity&gt; asylo::ParseSgxIdentity </td>
          <td>(</td>
          <td class="paramtype">const EnclaveIdentity &amp;&#160;</td>
          <td class="paramname"><em>generic_identity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses and validates <code>generic_identity</code>, returning an <code>SgxIdentity</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="ab8bd3881e5d037fd647e9106fe21c40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bd3881e5d037fd647e9106fe21c40d">&#9670;&nbsp;</a></span>ParseSgxIdentityExpectation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentityExpectation&gt; asylo::ParseSgxIdentityExpectation </td>
          <td>(</td>
          <td class="paramtype">const EnclaveIdentityExpectation &amp;&#160;</td>
          <td class="paramname"><em>generic_expectation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses and validates <code>generic_expectation</code>, returning an <code>SgxIdentityExpectation</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="ad262c8c9df110767787290855411b96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad262c8c9df110767787290855411b96c">&#9670;&nbsp;</a></span>ParseSgxIdentityMatchSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;SgxIdentityMatchSpec&gt; asylo::ParseSgxIdentityMatchSpec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>generic_match_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses and validates <code>generic_match_spec</code>, returning an <code>SgxIdentityMatchSpec</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="acf4324ed0a8827c59ee3f737173be7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4324ed0a8827c59ee3f737173be7fa">&#9670;&nbsp;</a></span>PeerNullCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::PeerNullCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-unauthenticated gRPC channel between two enclave entities. </p>
<p>A credential configured with these options enforces unidirectional authentication using the null identity. The null identity specifies no identity in particular, which means that in the resulting connection the peer does not authenticate.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#acf4324ed0a8827c59ee3f737173be7fa">PeerNullCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#acf4324ed0a8827c59ee3f737173be7fa">PeerNullCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unauthenticated on the peer's end. </dd></dl>

</div>
</div>
<a id="ae0f89d61e86e7c51a77b268b1c68bf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f89d61e86e7c51a77b268b1c68bf48">&#9670;&nbsp;</a></span>PeerSgxAgeRemoteCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::PeerSgxAgeRemoteCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel where it accepts identities attested by a remote SGX enclave using Asylo's Assertion Generator Enclave. </p>
<p>A credential configured with these options enforces that the peer authenticates using SGX enclave code identity attested by Asylo's Assertion Generator Enclave..</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#ae0f89d61e86e7c51a77b268b1c68bf48">PeerSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#ae0f89d61e86e7c51a77b268b1c68bf48">PeerSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unidirectionally-authenticated on the peer's end using SGX enclave code identity. </dd></dl>

</div>
</div>
<a id="a8dc68a49014050276695e89b190eab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc68a49014050276695e89b190eab7d">&#9670;&nbsp;</a></span>PeerSgxLocalCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::PeerSgxLocalCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel between two local SGX enclaves. </p>
<p>A credential configured with these options enforces that the peer authenticates using SGX enclave code identity.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#a8dc68a49014050276695e89b190eab7d">PeerSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#a8dc68a49014050276695e89b190eab7d">PeerSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unidirectionally-authenticated on the peer's end using SGX enclave code identity. </dd></dl>

</div>
</div>
<a id="a441880ecccdc19e349c3440f9425f041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441880ecccdc19e349c3440f9425f041">&#9670;&nbsp;</a></span>PosixError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::PosixError </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>message</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> representing a POSIX error. </p>
<p>If <code>errnum</code> is zero, <code><a class="el" href="namespaceasylo.html#a441880ecccdc19e349c3440f9425f041" title="Returns a Status representing a POSIX error. ">PosixError()</a></code> returns an OK status. Otherwise, the returned error message includes the POSIX error explanation string.</p>
<p>Callers should not rely on how <code><a class="el" href="namespaceasylo.html#a441880ecccdc19e349c3440f9425f041" title="Returns a Status representing a POSIX error. ">PosixError()</a></code> embeds error information in the returned <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>. Instead, callers can use <code><a class="el" href="namespaceasylo.html#adcbd4414f3eaa7d805e74b46ece741f2" title="Returns the POSIX error number that a Status represents, or zero if the Status does not represent a P...">GetErrno()</a></code> to inspect a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> for POSIX error information.</p>
<p>However, callers may rely on stability in the mapping between POSIX error numbers and <code>absl::StatusCode</code>s. Callers can also use this function to create <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>es that are understandable by other code that uses the POSIX error space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>A POSIX error number. See errno(3). </td></tr>
    <tr><td class="paramname">message</td><td>An optional message to prepend to the POSIX error explanation string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error representing <code>errnum</code>, or an OK status if <code>errnum</code> is zero. </dd></dl>

</div>
</div>
<a id="aac1fe9c46895980125695a1e727ff3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1fe9c46895980125695a1e727ff3f8">&#9670;&nbsp;</a></span>PosixErrorIs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PolymorphicStatusMatcherType asylo::PosixErrorIs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>-like object that contains the given POSIX error. </p>
<p>Works on any <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> that can be inspected by <code><a class="el" href="namespaceasylo.html#adcbd4414f3eaa7d805e74b46ece741f2" title="Returns the POSIX error number that a Status represents, or zero if the Status does not represent a P...">GetErrno()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>A POSIX error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GoogleTest matcher for POSIX errors representing <code>errnum</code>. </dd></dl>

</div>
</div>
<a id="ab1196326488d3e0a06805d29ff9ccf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1196326488d3e0a06805d29ff9ccf52">&#9670;&nbsp;</a></span>SelfNullCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::SelfNullCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-unauthenticated gRPC channel between two enclave entities. </p>
<p>A credential configured with these options enforces unidirectional authentication using the null identity. The null identity specifies no identity in particular, which means that in the resulting connection the credential holder does not authenticate.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#ab1196326488d3e0a06805d29ff9ccf52">SelfNullCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#ab1196326488d3e0a06805d29ff9ccf52">SelfNullCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unauthenticated on the credential holder's end. </dd></dl>

</div>
</div>
<a id="a81d92e7c2eacdf8539d0944dfcec62d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d92e7c2eacdf8539d0944dfcec62d8">&#9670;&nbsp;</a></span>SelfSgxAgeRemoteCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::SelfSgxAgeRemoteCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel. </p>
<p>A credential configured with these options enforces that the credential holder authenticates using SGX enclave code identity attested by Asylo's Assertion Generator Enclave.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#a81d92e7c2eacdf8539d0944dfcec62d8">SelfSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#a81d92e7c2eacdf8539d0944dfcec62d8">SelfSgxAgeRemoteCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unidirectionally-authenticated on the credential holder's end using SGX enclave code identity. </dd></dl>

</div>
</div>
<a id="a80ff2ebca6691694992b41a14fa8abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ff2ebca6691694992b41a14fa8abc1">&#9670;&nbsp;</a></span>SelfSgxLocalCredentialsOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasylo_1_1EnclaveCredentialsOptions.html">EnclaveCredentialsOptions</a> asylo::SelfSgxLocalCredentialsOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates options suitable for configuring a credential used in establishing a unidirectionally-authenticated gRPC channel between two local SGX enclaves. </p>
<p>A credential configured with these options enforces that the credential holder authenticates using SGX enclave code identity.</p>
<p>Sample usage for creating <code>::grpc::ChannelCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ChannelCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a6172f61ca6679f7d266b9aebbbc5238b">EnclaveChannelCredentials</a>(<a class="code" href="namespaceasylo.html#a80ff2ebca6691694992b41a14fa8abc1">SelfSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><p>Sample usage for creating <code>::grpc::ServerCredentials</code>:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;::grpc::ServerCredentials&gt; creds =</div><div class="line">  <a class="code" href="namespaceasylo.html#a41ae5afd47e724b67e79da0ef6d923fe">EnclaveServerCredentials</a>(<a class="code" href="namespaceasylo.html#a80ff2ebca6691694992b41a14fa8abc1">SelfSgxLocalCredentialsOptions</a>());</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Options used to configure gRPC credentials for a channel that is unidirectionally-authenticated on the credential holder's end using SGX enclave code identity. </dd></dl>

</div>
</div>
<a id="a1efd22a1bce025eaaa50373049e7ce5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efd22a1bce025eaaa50373049e7ce5b">&#9670;&nbsp;</a></span>SerializeSgxIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveIdentity&gt; asylo::SerializeSgxIdentity </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentity &amp;&#160;</td>
          <td class="paramname"><em>sgx_identity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes <code>sgx_identity</code>, returning an <code>EnclaveIdentity</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="a8c6ea453b59f2ef701998d8e1ecfdb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6ea453b59f2ef701998d8e1ecfdb1e">&#9670;&nbsp;</a></span>SerializeSgxIdentityExpectation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;EnclaveIdentityExpectation&gt; asylo::SerializeSgxIdentityExpectation </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentityExpectation &amp;&#160;</td>
          <td class="paramname"><em>sgx_expectation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes <code>sgx_expectation</code>, returning an <code>EnclaveIdentityExpectation</code> on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="a60b2a112de8fc90c2464a198c0b46a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b2a112de8fc90c2464a198c0b46a38">&#9670;&nbsp;</a></span>SerializeSgxIdentityMatchSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;std::string&gt; asylo::SerializeSgxIdentityMatchSpec </td>
          <td>(</td>
          <td class="paramtype">const SgxIdentityMatchSpec &amp;&#160;</td>
          <td class="paramname"><em>sgx_match_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes <code>sgx_match_spec</code>, returning a string on success or a non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> on failure. </p>

</div>
</div>
<a id="a718c2d6add34237eb404b06fe6694c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718c2d6add34237eb404b06fe6694c18">&#9670;&nbsp;</a></span>set_log_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asylo::set_log_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>log_directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the log directory, as specified when this enclave is initialized. </p>
<p>This is only set once. Any request to reset it will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_directory</td><td>The log file directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the log directory is set successfully. </dd></dl>

</div>
</div>
<a id="a6516088e3c0a326815df211461ad64d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516088e3c0a326815df211461ad64d0">&#9670;&nbsp;</a></span>set_vlog_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::set_vlog_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosity threshold for VLOG. </p>
<p>A VLOG command with a level greater than this will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The verbosity threshold for VLOG to be set. A VLOG command with level less than or equal to this will be logged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a830e6ca210017926c6f21138da33a6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830e6ca210017926c6f21138da33a6a6">&#9670;&nbsp;</a></span>SetEnclaveConfigDefaults() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetEnclaveConfigDefaults </td>
          <td>(</td>
          <td class="paramtype">const HostConfig &amp;&#160;</td>
          <td class="paramname"><em>host_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnclaveConfig *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Sets critical uninitialized fields in <code>config</code> to default values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_config</td><td>Values to set in the <code>host_config</code> field of <code>config</code>. </td></tr>
    <tr><td class="paramname">config[out]</td><td>EnclaveConfig object to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8053438ddafe4f065854cdee4a42c907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8053438ddafe4f065854cdee4a42c907">&#9670;&nbsp;</a></span>SetEnclaveConfigDefaults() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetEnclaveConfigDefaults </td>
          <td>(</td>
          <td class="paramtype">EnclaveConfig *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets critical uninitialized fields in <code>config</code> to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config[out]</td><td>EnclaveConfig object to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6f115259e564d5ade4096cd5e3ecf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f115259e564d5ade4096cd5e3ecf05">&#9670;&nbsp;</a></span>SetNullAssertionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetNullAssertionDescription </td>
          <td>(</td>
          <td class="paramtype">AssertionDescription *&#160;</td>
          <td class="paramname"><em>assertion_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>assertion_description</code> to describe a null assertion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertion_description</td><td>The <code>AssertionDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84e0cc85f971fa29aa075eeed43b772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e0cc85f971fa29aa075eeed43b772d">&#9670;&nbsp;</a></span>SetNullIdentityDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetNullIdentityDescription </td>
          <td>(</td>
          <td class="paramtype">EnclaveIdentityDescription *&#160;</td>
          <td class="paramname"><em>identity_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>identity_description</code> to describe a null identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identity_description</td><td>The <code>EnclaveIdentityDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a347d5d9d0a8894a03cbfa23f3b69fd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d5d9d0a8894a03cbfa23f3b69fd97">&#9670;&nbsp;</a></span>SetProtoPayload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageT , typename StatusT  = Status&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetProtoPayload </td>
          <td>(</td>
          <td class="paramtype">const MessageT &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatusT &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a payload of type <code>MessageT</code> to <code>status</code>. </p>
<p><code>MessageT</code> must be a protobuf message type. Note that a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> can only have one payload of any given message type.</p>
<p>The message is embedded with the same type URL that would be used to pack the message into a <code>google::protobuf::Any</code>.</p>
<p>The <code>status</code> argument may be either an Asylo <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> or an <code>absl::Status</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">message</td><td>A protobuf message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">status</td><td>The status to add the payload to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cfcb13ce45083bea24d7a2dcba884f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfcb13ce45083bea24d7a2dcba884f9">&#9670;&nbsp;</a></span>SetSgxAgeRemoteAssertionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetSgxAgeRemoteAssertionDescription </td>
          <td>(</td>
          <td class="paramtype">AssertionDescription *&#160;</td>
          <td class="paramname"><em>assertion_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>assertion_description</code> to describe an SGX remote assertion generated by the Assertion Generator Enclave (AGE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertion_description</td><td>The <code>AssertionDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4fbde1c34a3cbc7e847eac196fdf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4fbde1c34a3cbc7e847eac196fdf47">&#9670;&nbsp;</a></span>SetSgxIdentityDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetSgxIdentityDescription </td>
          <td>(</td>
          <td class="paramtype">EnclaveIdentityDescription *&#160;</td>
          <td class="paramname"><em>identity_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>identity_description</code> to describe an SGX identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identity_description</td><td>The <code>EnclaveIdentityDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0133e34526b1df93bbbfb5382560d479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0133e34526b1df93bbbfb5382560d479">&#9670;&nbsp;</a></span>SetSgxIntelEcdsaQeRemoteAssertionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetSgxIntelEcdsaQeRemoteAssertionDescription </td>
          <td>(</td>
          <td class="paramtype">AssertionDescription *&#160;</td>
          <td class="paramname"><em>assertion_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>assertion_description</code> to describe an SGX remote assertion generated by the Intel ECDSA Quoting Enclave (QE). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertion_description</td><td>The <code>AssertionDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18d12c2532052365108e2b59a466cfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d12c2532052365108e2b59a466cfce">&#9670;&nbsp;</a></span>SetSgxLocalAssertionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asylo::SetSgxLocalAssertionDescription </td>
          <td>(</td>
          <td class="paramtype">AssertionDescription *&#160;</td>
          <td class="paramname"><em>assertion_description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>assertion_description</code> to describe an SGX local assertion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertion_description</td><td>The <code>AssertionDescription</code> to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada0afce34d0ddf38d563a04267c1b922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0afce34d0ddf38d563a04267c1b922">&#9670;&nbsp;</a></span>StatusFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::StatusFromProto </td>
          <td>(</td>
          <td class="paramtype">const StatusProto &amp;&#160;</td>
          <td class="paramname"><em>status_proto</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> based on the contents of the given <code>status_proto</code>. </p>
<p>If the error space given by <code>status_proto.space()</code> is unrecognized, the returned <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> is in the canonical error space and has an error code equal to <code>status_proto.canonical_code()</code>. If <code>status_proto</code> has no canonical code, the returned <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> has an error code of <code>absl::StatusCode::kUnknown</code>. Note that the error message is only set if <code>status_proto</code> represents a non-OK status.</p>
<p>If the given <code>status_proto</code> is invalid, then the returned <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> has an appropriate error code and message. A <code>StatusProto</code> is valid if and only if all the following conditions hold:</p>
<ul>
<li>If <code>code()</code> is 0, then <code>canonical_code()</code> is set to 0.</li>
<li>If <code>canonical_code()</code> is 0, then <code>code()</code> is set to 0.</li>
<li>If the error space is recognized, then <code>canonical_code()</code> is equal to the equivalent canonical code given by the error space.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_proto</td><td>A protobuf object to unpack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> based on the contents of <code>status_proto</code>. </dd></dl>

</div>
</div>
<a id="a7b2dc8bbc3b091a862b6617ababd6334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2dc8bbc3b091a862b6617ababd6334">&#9670;&nbsp;</a></span>StatusToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusProto asylo::StatusToProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the contents of <code>status</code> into a <code>StatusProto</code>. </p>
<p>This function sets the <code>space</code> and <code>canonical_code</code> fields in <code>status_proto</code> even if <code>status</code> is in the canonical error space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>A <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> to pack into a proto. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>StatusProto</code> representing <code>status</code>. </dd></dl>

</div>
</div>
<a id="af10bde933e306f1bce56bbc454289b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10bde933e306f1bce56bbc454289b18">&#9670;&nbsp;</a></span>ValidateSha256HashProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::ValidateSha256HashProto </td>
          <td>(</td>
          <td class="paramtype">const Sha256HashProto &amp;&#160;</td>
          <td class="paramname"><em>hash_proto</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates that |hash_proto| has a hash that is exactly 32 bytes. </p>

</div>
</div>
<a id="a59ebb437b3c00856f9a9054ef47feb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ebb437b3c00856f9a9054ef47feb30">&#9670;&nbsp;</a></span>WithContext() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1Status.html">Status</a> asylo::WithContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasylo_1_1Status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> with the provided context prepended to its error message. </p>
<p>Returns <code><a class="el" href="namespaceasylo.html#ac03025d792be214c036d83424e26cd48" title="Returns an OK status object. ">OkStatus()</a></code> if the given <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> is OK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>A <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> to add context to. </td></tr>
    <tr><td class="paramname">context</td><td>Additional context to add to the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>status</code> with <code>context</code> prepended, along with an appropriate separator. </dd></dl>

</div>
</div>
<a id="ad77584ecb42f762606be6cec5670bd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77584ecb42f762606be6cec5670bd5f">&#9670;&nbsp;</a></span>WithContext() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;T&gt; asylo::WithContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>status_or</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code> overload above, but for <code><a class="el" href="classasylo_1_1StatusOr.html" title="A class for representing either a usable value, or an error. ">StatusOr</a>&lt;T&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>A <code><a class="el" href="classasylo_1_1StatusOr.html" title="A class for representing either a usable value, or an error. ">StatusOr</a>&lt;T&gt;</code> to add context to, if it is not OK. </td></tr>
    <tr><td class="paramname">context</td><td>Additional context to add to the <code><a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>status_or</code> if it is OK, otherwise <code>status_or.status()</code> with <code>context</code> prepended to the error message. </dd></dl>

</div>
</div>
<a id="ae9f0d204d1c203d43bb8181b5a95095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f0d204d1c203d43bb8181b5a95095a">&#9670;&nbsp;</a></span>WithContext() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt;T&gt; asylo::WithContext </td>
          <td>(</td>
          <td class="paramtype">absl::StatusOr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>status_or</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As the <code><a class="el" href="classasylo_1_1StatusOr.html" title="A class for representing either a usable value, or an error. ">StatusOr</a>&lt;T&gt;</code> overload above, but for <code>absl::StatusOr&lt;T&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>An <code>absl::StatusOr&lt;T&gt;</code> to add context to, if it is not OK. </td></tr>
    <tr><td class="paramname">context</td><td>Additional context to add to the <code>absl::Status</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>status_or</code> if it is OK, otherwise <code>status_or.status()</code> with <code>context</code> prepended to the error message. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4fac12ece837aca860004ddc0eecd5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fac12ece837aca860004ddc0eecd5df">&#9670;&nbsp;</a></span>kStatusMoveAssignmentMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_CONST_INIT const char asylo::kStatusMoveAssignmentMsg[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affd5688a45e23af3310b88489b7def41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd5688a45e23af3310b88489b7def41">&#9670;&nbsp;</a></span>kStatusMoveConstructorMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_CONST_INIT const char asylo::kStatusMoveConstructorMsg[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b5996a0b819b65f1a8d281beb8f4fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5996a0b819b65f1a8d281beb8f4fff">&#9670;&nbsp;</a></span>kValueMoveAssignmentMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_CONST_INIT const char asylo::kValueMoveAssignmentMsg[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3761b184f111021d5bbee1139d21a7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761b184f111021d5bbee1139d21a7b9">&#9670;&nbsp;</a></span>kValueMoveConstructorMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_CONST_INIT const char asylo::kValueMoveConstructorMsg[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65c326357c7452aac96ee0e128dd0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65c326357c7452aac96ee0e128dd0e6">&#9670;&nbsp;</a></span>kValueOrDieMovedMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_CONST_INIT const char asylo::kValueOrDieMovedMsg[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
