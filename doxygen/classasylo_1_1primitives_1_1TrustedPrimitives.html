<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asylo: asylo::primitives::TrustedPrimitives Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="/favicons/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asylo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasylo.html">asylo</a></li><li class="navelem"><a class="el" href="namespaceasylo_1_1primitives.html">primitives</a></li><li class="navelem"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html">TrustedPrimitives</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classasylo_1_1primitives_1_1TrustedPrimitives-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asylo::primitives::TrustedPrimitives Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Trusted runtime primitive interface.  
 <a href="classasylo_1_1primitives_1_1TrustedPrimitives.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="trusted__primitives_8h_source.html">asylo/platform/primitives/trusted_primitives.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a003c24fa254029e06ba8d2be087e6680"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a003c24fa254029e06ba8d2be087e6680">BestEffortAbort</a> (const char *message)</td></tr>
<tr class="memdesc:a003c24fa254029e06ba8d2be087e6680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the enclave on a best-effort basis.  <a href="#a003c24fa254029e06ba8d2be087e6680">More...</a><br /></td></tr>
<tr class="separator:a003c24fa254029e06ba8d2be087e6680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ecf17d986e25c90cda488b4e6fa4e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#aa8ecf17d986e25c90cda488b4e6fa4e2">DebugPuts</a> (const char *message)</td></tr>
<tr class="memdesc:aa8ecf17d986e25c90cda488b4e6fa4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message to a stream suitable for debug output.  <a href="#aa8ecf17d986e25c90cda488b4e6fa4e2">More...</a><br /></td></tr>
<tr class="separator:aa8ecf17d986e25c90cda488b4e6fa4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a5fc51a2005c0f746c68ad140875d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#adc5a5fc51a2005c0f746c68ad140875d">IsInsideEnclave</a> (const void *addr, size_t size) ASYLO_MUST_USE_RESULT</td></tr>
<tr class="memdesc:adc5a5fc51a2005c0f746c68ad140875d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A predicate that decides if a region of memory is internal to the enclave.  <a href="#adc5a5fc51a2005c0f746c68ad140875d">More...</a><br /></td></tr>
<tr class="separator:adc5a5fc51a2005c0f746c68ad140875d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a2a5f8c8a840344ab1134b8d9bf94"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a755a2a5f8c8a840344ab1134b8d9bf94">IsOutsideEnclave</a> (const void *addr, size_t size) ASYLO_MUST_USE_RESULT</td></tr>
<tr class="memdesc:a755a2a5f8c8a840344ab1134b8d9bf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">A predicate that decides if a region of memory is external to the enclave.  <a href="#a755a2a5f8c8a840344ab1134b8d9bf94">More...</a><br /></td></tr>
<tr class="separator:a755a2a5f8c8a840344ab1134b8d9bf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010174bcff63bee3b9cde3d8856cbe6a"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a010174bcff63bee3b9cde3d8856cbe6a">UntrustedLocalAlloc</a> (size_t size) noexcept ASYLO_MUST_USE_RESULT</td></tr>
<tr class="memdesc:a010174bcff63bee3b9cde3d8856cbe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates <code>size</code> bytes of untrusted local memory.  <a href="#a010174bcff63bee3b9cde3d8856cbe6a">More...</a><br /></td></tr>
<tr class="separator:a010174bcff63bee3b9cde3d8856cbe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e0540a21ee485cd344ffe411269084"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a59e0540a21ee485cd344ffe411269084">UntrustedLocalFree</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a59e0540a21ee485cd344ffe411269084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls untrusted local counterpart to free memory allocated by malloc in local untrusted code or by calling UntrustedLocalAlloc.  <a href="#a59e0540a21ee485cd344ffe411269084">More...</a><br /></td></tr>
<tr class="separator:a59e0540a21ee485cd344ffe411269084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46feaffa585fc1120f11a64188923c6d"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a46feaffa585fc1120f11a64188923c6d">UntrustedLocalMemcpy</a> (void *dest, const void *src, size_t size) noexcept</td></tr>
<tr class="memdesc:a46feaffa585fc1120f11a64188923c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>size</code> bytes of memory from <code>src</code> to <code>dest</code>.  <a href="#a46feaffa585fc1120f11a64188923c6d">More...</a><br /></td></tr>
<tr class="separator:a46feaffa585fc1120f11a64188923c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c266bbf9285bb0f8c40d0e53871fc12"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classasylo_1_1primitives_1_1PrimitiveStatus.html">PrimitiveStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#a5c266bbf9285bb0f8c40d0e53871fc12">UntrustedCall</a> (uint64_t untrusted_selector, MessageWriter *input, MessageReader *output) ASYLO_MUST_USE_RESULT</td></tr>
<tr class="memdesc:a5c266bbf9285bb0f8c40d0e53871fc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits the enclave synchronously at an entry point to untrusted code designated by <code>untrusted_selector</code>.  <a href="#a5c266bbf9285bb0f8c40d0e53871fc12">More...</a><br /></td></tr>
<tr class="separator:a5c266bbf9285bb0f8c40d0e53871fc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94cd4537abde482357779f46afb659a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classasylo_1_1primitives_1_1PrimitiveStatus.html">PrimitiveStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#ab94cd4537abde482357779f46afb659a">RegisterEntryHandler</a> (uint64_t trusted_selector, const <a class="el" href="structasylo_1_1primitives_1_1EntryHandler.html">EntryHandler</a> &amp;handler) ASYLO_MUST_USE_RESULT</td></tr>
<tr class="memdesc:ab94cd4537abde482357779f46afb659a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback as the handler routine for an enclave entry point trusted_selector.  <a href="#ab94cd4537abde482357779f46afb659a">More...</a><br /></td></tr>
<tr class="separator:ab94cd4537abde482357779f46afb659a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c5f731612dcacf9df0ad5f66863047"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1primitives_1_1TrustedPrimitives.html#ab0c5f731612dcacf9df0ad5f66863047">CreateThread</a> ()</td></tr>
<tr class="memdesc:ab0c5f731612dcacf9df0ad5f66863047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="#ab0c5f731612dcacf9df0ad5f66863047">More...</a><br /></td></tr>
<tr class="separator:ab0c5f731612dcacf9df0ad5f66863047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Trusted runtime primitive interface. </p>
<p>This class declares the primitive API available to trusted application code running inside an Asylo enclave. Each Asylo backend is responsible for providing an implementation of this interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a003c24fa254029e06ba8d2be087e6680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003c24fa254029e06ba8d2be087e6680">&#9670;&nbsp;</a></span>BestEffortAbort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void asylo::primitives::TrustedPrimitives::BestEffortAbort </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts the enclave on a best-effort basis. </p>
<p>Since it may not be possible to destroy the enclave completely without the cooperation of untrusted code, the implementation should clearly document the behavior of aborting on a particular backend.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A message for the abort method to print or log. May be nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c5f731612dcacf9df0ad5f66863047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c5f731612dcacf9df0ad5f66863047">&#9670;&nbsp;</a></span>CreateThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int asylo::primitives::TrustedPrimitives::CreateThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<p>Depending on the backend, the implementation might or might not need to exit the enclave for thread creation. The created thread is responsible for making a callback for querying the thread manager to register itself and then execute the callback function provided by the thread manager.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a id="aa8ecf17d986e25c90cda488b4e6fa4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ecf17d986e25c90cda488b4e6fa4e2">&#9670;&nbsp;</a></span>DebugPuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void asylo::primitives::TrustedPrimitives::DebugPuts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a message to a stream suitable for debug output. </p>
<p>This API is intended for low-level debugging and should:</p>
<ul>
<li>Take as few dependencies as possible.</li>
<li>Make as few assumptions about the runtime as possible.</li>
<li>Flush as immediately as possible.</li>
<li>Not assume that the I/O or logging subsystems are usable.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5a5fc51a2005c0f746c68ad140875d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5a5fc51a2005c0f746c68ad140875d">&#9670;&nbsp;</a></span>IsInsideEnclave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool asylo::primitives::TrustedPrimitives::IsInsideEnclave </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A predicate that decides if a region of memory is internal to the enclave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to the start of the memory region. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes that will be tested for enclave residence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every byte of a <code>size</code> byte range at an address <code>addr</code> falls inside the TCB and may not be modified by untrusted code. </dd></dl>

</div>
</div>
<a id="a755a2a5f8c8a840344ab1134b8d9bf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a2a5f8c8a840344ab1134b8d9bf94">&#9670;&nbsp;</a></span>IsOutsideEnclave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool asylo::primitives::TrustedPrimitives::IsOutsideEnclave </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A predicate that decides if a region of memory is external to the enclave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to the start of the memory region. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes that will be tested for enclave non-residence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if every byte of a <code>size</code> byte range at an address <code>addr</code> falls outside the TCB and may be modified by untrusted code. </dd></dl>

</div>
</div>
<a id="ab94cd4537abde482357779f46afb659a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94cd4537abde482357779f46afb659a">&#9670;&nbsp;</a></span>RegisterEntryHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classasylo_1_1primitives_1_1PrimitiveStatus.html">PrimitiveStatus</a> asylo::primitives::TrustedPrimitives::RegisterEntryHandler </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>trusted_selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structasylo_1_1primitives_1_1EntryHandler.html">EntryHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a callback as the handler routine for an enclave entry point trusted_selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trusted_selector</td><td>A unique-to-this-enclave identification number which will be used to select the given <a class="el" href="structasylo_1_1primitives_1_1EntryHandler.html" title="Callback structure for dispatching messages passed to the enclave. ">EntryHandler</a>. </td></tr>
    <tr><td class="paramname">handler</td><td>The representation of a callable enclave function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error status if a handler has already been registered for <code>trusted_selector</code> or if an invalid selector value is passed. </dd></dl>

</div>
</div>
<a id="a5c266bbf9285bb0f8c40d0e53871fc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c266bbf9285bb0f8c40d0e53871fc12">&#9670;&nbsp;</a></span>UntrustedCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classasylo_1_1primitives_1_1PrimitiveStatus.html">PrimitiveStatus</a> asylo::primitives::TrustedPrimitives::UntrustedCall </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>untrusted_selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageWriter *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageReader *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exits the enclave synchronously at an entry point to untrusted code designated by <code>untrusted_selector</code>. </p>
<p>Inputs must be pushed into <code>input</code>. Results are returned in <code>output</code>. All extent data in <code>input</code> and <code>output</code> are owned by them and located in trusted memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">untrusted_selector</td><td>The identification number to select a registered handler in the untrusted space. </td></tr>
    <tr><td class="paramname">input</td><td>A pointer to a MessageWriter, into which all call inputs must be pushed. </td></tr>
    <tr><td class="paramname">output</td><td>A pointer to a MessageReader from which to read outputs from the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status for the call action, since the call itself may fail. </dd></dl>

</div>
</div>
<a id="a010174bcff63bee3b9cde3d8856cbe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010174bcff63bee3b9cde3d8856cbe6a">&#9670;&nbsp;</a></span>UntrustedLocalAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* asylo::primitives::TrustedPrimitives::UntrustedLocalAlloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates <code>size</code> bytes of untrusted local memory. </p>
<p>The allocated memory must later be freed by calling UntrustedLocalFree or by free call in local untrusted code. Local untrusted memory may not be addressable by the enclave directly, as this is a backend-specific assumption. Untrusted memory contents are not secure. One must assume that an attacker can read and write it. Note that untrusted local memory is not the same as host memory, and that untrusted local memory is not expected to be addressable from the untrusted application. If a backend permits directly addressing untrusted memory, portable applications should not use that capability. Only local primitives should use direct addressibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="a59e0540a21ee485cd344ffe411269084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e0540a21ee485cd344ffe411269084">&#9670;&nbsp;</a></span>UntrustedLocalFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void asylo::primitives::TrustedPrimitives::UntrustedLocalFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls untrusted local counterpart to free memory allocated by malloc in local untrusted code or by calling UntrustedLocalAlloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to untrusted memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46feaffa585fc1120f11a64188923c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46feaffa585fc1120f11a64188923c6d">&#9670;&nbsp;</a></span>UntrustedLocalMemcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* asylo::primitives::TrustedPrimitives::UntrustedLocalMemcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies <code>size</code> bytes of memory from <code>src</code> to <code>dest</code>. </p>
<p>Backends seeking to access or copy untrusted local memory should not assume direct memory access, and instead use this function to copy to/from the untrusted local memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The trusted or untrusted local destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>The trusted or untrusted local source memory. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to destination buffer where memory got copied. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>asylo/platform/primitives/<a class="el" href="trusted__primitives_8h_source.html">trusted_primitives.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
